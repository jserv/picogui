/* $Id: serial40x4.c,v 1.4 2001/05/12 22:45:51 micahjd Exp $
 *
 * serial40x4.c - PicoGUI video driver for a serial wall-mounted
 *                40x4 character LCD I put together about a year ago.
 *                This driver is very similar to the ncurses driver, but
 *                includes lower level support for this LCD. All LCD commands
 *                are sent to /dev/lcd, which can be a symbolic link to a
 *                serial port (already in the right configuration) that the
 *                LCD is attached to.
 * 
 * ------ Data format used by the serial LCD
 * 
 * Serial data at 9600 baud, 8-N-1. Unless otherwise specified, a character
 * sent to the LCD is inserted at the cursor location, and the cursor location
 * is advanced. The 40x4 LCD is made up of two 40x2 HD44780-compatible
 * LCD controllers, each with its own parameters and custom characters
 * independant of the other. The display recognizes the following escape codes:
 * 
 *  \\    Insert a '\' character
 *  \1    Switch to first (top) LCD controller
 *  \2    Switch to second (bottom) LCD controller
 *  \*    Send commands to all LCD controllers simult-aneously
 *  \c?   Sends a one-character LCD command, see HD44780 docs
 *  \s    Clear screen
 *  \g    Put cursor at the beginning of character-generator RAM
 *  \d    Put cursor at the beginning of display RAM
 *  \b    Beep the LCD unit's speaker
 *  \f    Flash the LCD unit's LED
 *  \n    Go to the second line of the selected LCD controller
 * 
 * The LCD unit's firmware is a C program running on a PIC16C84
 * microcontroller. It is designed to be compiled using the 'c2c' compiler
 * available for Linux.
 *
 * Source code is included in the file serial40x4.firmware.c, released to the
 * public domain.
 * 
 * ------
 *
 * PicoGUI small and efficient client/server GUI
 * Copyright (C) 2000,2001 Micah Dowty <micahjd@users.sourceforge.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * 
 * Contributors:
 * 
 * 
 * 
 */

#include <pgserver/common.h>

#include <pgserver/video.h>
#include <pgserver/input.h>
#include <pgserver/appmgr.h>
#include <pgserver/font.h>
#include <pgserver/render.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/* Macros to easily access the members of vid->display */
#define FB_MEM   (((struct stdbitmap*)vid->display)->bits)
#define FB_BPL   (((struct stdbitmap*)vid->display)->pitch)

/* A shadow buffer so we can see what has changed */
u8 *lcd_shadow;

int lcd_fd;

/******************************************** Fake font */
/* This is a little hack to trick PicoGUI's text rendering */

/* Font width table: all chars are 1 character wide! */
u8 const serial40x4_font_vwtab[256] = {
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};

/* Table of indices to the bitmap table.
 * Each character is one character long, so this is simple.
 */
u32 const serial40x4_font_trtab[256] = {
   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
   0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
   0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
   0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
   0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
   0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
   0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
   0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
   0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
   0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,
   0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,
   0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
   0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
   0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
   0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF
};

/* Table of font 'bitmaps', really just their character code.
 */
u8 const serial40x4_font_bitmaps[256] = {
   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
   0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
   0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
   0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
   0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
   0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
   0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
   0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
   0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
   0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,
   0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,
   0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
   0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
   0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
   0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF
};

struct font const serial40x4_font = {
   /* bitmaps = */ (u8*) &serial40x4_font_bitmaps,
   /* h = */ 1,
   /* hspace = */ 0,
   /* vspace = */ 0,
   /* vwtab = */ (u8*) &serial40x4_font_vwtab,
   /* trtab = */ (u32*) &serial40x4_font_trtab
};

/* Bogus fontstyle node */
struct fontstyle_node serial40x4_font_style = {
   /* name = */ "LCD Pseudofont",
   /* size = */ 1,
   /* flags = */ PG_FSTYLE_FIXED,
   /* next = */ NULL,
   /* normal = */ (struct font *) &serial40x4_font,
   /* bold = */ NULL,
   /* italic = */ NULL,
   /* bolditalic = */ NULL,
   /* ulineh = */ 1,
   /* slineh = */ 0,
   /* boldw = */ 0
};

/* Custom characters (needed for large text) */
u8 const cg1[] = {
     0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
     0x1F,0x1F,0x1F,0x1F,0x1F,0x00,0x00,0x00,
     0x00,0x00,0x00,0x1F,0x1F,0x1F,0x1F,0x1F,
     0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,
     0x00,0x00,0x00,0x10,0x18,0x1C,0x1E,0x1F,
     0x1F,0x1F,0x1E,0x1E,0x1C,0x1C,0x18,0x10,
     0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,
     0x00,0x00,0x15,0x00,0x00,0x15,0x00,0x00
};
u8 const cg2[] = {
     0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
     0x1F,0x1F,0x1F,0x1F,0x1F,0x00,0x00,0x00,
     0x00,0x00,0x00,0x1F,0x1F,0x1F,0x1F,0x1F,
     0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,
     0x1F,0x1E,0x1C,0x18,0x10,0x00,0x00,0x00,
     0x10,0x18,0x1C,0x1C,0x1E,0x1E,0x1F,0x1F,
     0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,
     0x00,0x00,0x15,0x00,0x00,0x15,0x00,0x00
};

/******************************************** Implementations */

g_error serial40x4_init(void) {
   int i;
   g_error e;
   unsigned long size;
   u8 *p;

   vid->xres = 40;
   vid->yres = 4;
   vid->bpp  = 8;
   FB_BPL = 64;
   
   /* Allocate our buffer (framebuffer and shadow) */
   e = g_malloc((void**) &FB_MEM,FB_BPL * vid->yres * 2);
   errorcheck;
   lcd_shadow = FB_MEM + FB_BPL * vid->yres;
   memset(FB_MEM,0,FB_BPL * vid->yres * 2);
   
   /* Open LCD device */
   lcd_fd = open("/dev/lcd",O_WRONLY);
   if (lcd_fd<=0)
     return mkerror(PG_ERRT_IO,46);
    
   /* Download custom characters to the LCD */
   write(lcd_fd,"\\1\\g",4);
   write(lcd_fd,cg1,64);
   write(lcd_fd,"\\2\\g",4);
   write(lcd_fd,cg2,64);
   
   return sucess;
}

void serial40x4_close(void) {
   g_free(FB_MEM);   /* And shadow buffer */
   close(lcd_fd);
}

/* Use a shadow buffer to send RLE-delta encoded data to the LCD.
 *
 * Cruftily hardcoded to a split 40x4 Hitachi-compatible LCD
 */
void serial40x4_update(s16 x,s16 y,s16 w,s16 h) {
   int i_lcd,i;
   u8 *oldp,*newp;
   /* Output buffer big enough to hold one frame with worst-case encoding */
   u8 outbuf[1024];
   u8 *outp = outbuf;
   
   /* start comparing the buffers */
   i_lcd = -1;
   oldp = lcd_shadow;
   newp = FB_MEM;
   for (i=0;i<256;oldp++,newp++,i++) {
      if (*oldp == *newp)
	continue;
      
      /* Move the hardware cursor if necessary*/
      if (i_lcd != i) {

	 /* set the proper controller */
	 if (i>=128) {
	    if (i_lcd < 128) {
	       *(outp++) = '\\';
	       *(outp++) = '2';
	    }
	 }
	 else {
	    if (i_lcd<0 || i_lcd>=128) {
	       *(outp++) = '\\';
	       *(outp++) = '1';
	    }
	 }

	 /* set address */
	 *(outp++) = '\\';
	 *(outp++) = 'c';
	 *(outp++) = 0x80 + (i%128);   /* HD44780 DDRAM command */
	 i_lcd = i;
      }
      
      /* Output character */
      *(outp++) = *newp;
      if (i_lcd!=127)            /* barrier between controllers */
	i_lcd++;
      if (i_lcd==40)             /* Weird line wrapping */
	i_lcd = 64;
      if (i_lcd==168)            /* Weird line wrapping */
	i_lcd = 192;
   }

   /* Write buffer contents */
   write(lcd_fd,outbuf,outp-outbuf);
   
   /* Update the shadow buffer */
   memcpy(lcd_shadow,FB_MEM,256);
}

/**** Hack the normal font rendering a bit so we use regular text */

void serial40x4_charblit(hwrbitmap dest, u8 *chardat,s16 dest_x,
		      s16 dest_y,s16 w,s16 h,s16 lines,s16 angle,
		      hwrcolor c,struct quad *clip,bool fill, hwrcolor bg,
		      s16 lgop) {

   if (clip && (dest_x<clip->x1 || dest_y<clip->y1 ||
		dest_x>clip->x2 || dest_y>clip->y2))
     return;   

   /* Not at all correct, but until terminal theming support works it's
    * the only way to make pterm look ok */
   if (fill)
     (*vid->pixel)(dest,dest_x,dest_y,0,lgop);
   else
     (*vid->pixel)(dest,dest_x,dest_y,*chardat,lgop);
}
   
void serial40x4_font_newdesc(struct fontdesc *fd) {
   fd->font = (struct font *) &serial40x4_font;
   fd->margin = 0;
   fd->hline = -1;
   fd->italicw = 0;
   fd->fs = &serial40x4_font_style;
}

/* Like the ncurses driver, if 0x20000000 is set, it's a raw character code.
 * Otherwise, convert to black-and-white */

hwrcolor serial40x4_color_pgtohwr(pgcolor c) {
   if (c & 0x20000000) {
      /* Normal character:  0x200000CC */
      
      return (c & 0x0000FF);
   }
   else {
      /* Black and white, tweaked for better contrast */
      return ((getred(c)+getgreen(c)+getblue(c)) >= 382) ? ' ' : 0; 
   }
   
}

/******************************************** Driver registration */

g_error serial40x4_regfunc(struct vidlib *v) {
   setvbl_linear8(v);
   
   v->init = &serial40x4_init;
   v->close = &serial40x4_close;
   v->update = &serial40x4_update;  
   v->color_pgtohwr = &serial40x4_color_pgtohwr;
   v->font_newdesc = &serial40x4_font_newdesc;
   v->charblit = &serial40x4_charblit;

   return sucess;
}

/* The End */
