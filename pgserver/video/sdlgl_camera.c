/* $Id: sdlgl_camera.c,v 1.4 2002/07/03 22:03:31 micahjd Exp $
 *
 * sdlgl_camera.c - OpenGL driver for picogui, using SDL for portability.
 *                  This is an input filter that traps keyboard and mouse
 *                  input for camera control and other on-the-fly settings.
 *
 * PicoGUI small and efficient client/server GUI
 * Copyright (C) 2000-2002 Micah Dowty <micahjd@users.sourceforge.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * 
 * Contributors:
 * 
 * 
 * 
 */

#include <pgserver/common.h>
#include <pgserver/sdlgl.h>

/* We need access to sdlinput's cursor */
extern struct cursor *sdlinput_cursor;

/********************************************** Input filter ****/

void infilter_sdlgl_handler(struct infilter *self, u32 trigger, union trigparam *param) {
  float dx,dy,dz=0;
  s16 cursorx,cursory;
  float scale;

  /* Entering/leaving modes 
   */
  if ((param->kbd.mods & PGMOD_CTRL) && (param->kbd.mods & PGMOD_ALT) && trigger==PG_TRIGGER_KEYDOWN)
    switch (param->kbd.key) {

      /* Camera modes */

    case PGKEY_q:
      if (gl_global.camera_mode == SDLGL_CAMERAMODE_TRANSLATE)
	gl_global.camera_mode = SDLGL_CAMERAMODE_NONE;
      else
	gl_global.camera_mode = SDLGL_CAMERAMODE_TRANSLATE;
      gl_global.need_update++;
      return;

    case PGKEY_e:
      if (gl_global.camera_mode == SDLGL_CAMERAMODE_ROTATE)
	gl_global.camera_mode = SDLGL_CAMERAMODE_NONE;
      else
	gl_global.camera_mode = SDLGL_CAMERAMODE_ROTATE;
      gl_global.need_update++;
      return;

    case PGKEY_r:
      gl_global.camera_mode = SDLGL_CAMERAMODE_NONE;
      glLoadIdentity();
      gl_matrix_pixelcoord();
      gl_global.need_update++;
      return;

      /* Misc flags */

    case PGKEY_f:
      gl_global.showfps = !gl_global.showfps;
      gl_global.need_update++;
      return;

    case PGKEY_g:
      gl_global.grid = !gl_global.grid;
      gl_global.need_update++;
      return;

    case PGKEY_w:
      gl_global.wireframe = !gl_global.wireframe;
      gl_global.need_update++;
      return;
    }
  
  /* In a camera mode? 
   */
  if (gl_global.camera_mode != SDLGL_CAMERAMODE_NONE) {

    /* Keep track of pressed keys 
     */
    if (trigger == PG_TRIGGER_KEYDOWN)
      gl_global.pressed_keys[param->kbd.key] = 1;
    if (trigger == PG_TRIGGER_KEYUP)
      gl_global.pressed_keys[param->kbd.key] = 0;

    /* A couple keys should exit camera mode... 
     */
    if (trigger == PG_TRIGGER_KEYDOWN)
      switch (param->kbd.key) {
      case PGKEY_ESCAPE:
      case PGKEY_SPACE:
      case PGKEY_RETURN:
	gl_global.camera_mode = SDLGL_CAMERAMODE_NONE;
	gl_global.need_update++;
      }

    /* If this was a mouse movement from SDL, get the 
     * relative movement then warp the SDL cursor back to the center
     */
    if ((trigger & (PG_TRIGGER_MOVE | PG_TRIGGER_UP | PG_TRIGGER_DOWN)) && 
	param->mouse.cursor == sdlinput_cursor) {
      int oldx,oldy;

      /* Measure the relative motion */
      cursor_getposition(param->mouse.cursor,&oldx,&oldy);
      dx = param->mouse.x - oldx;
      dy = param->mouse.y - oldy;

      /* If there was no motion, it's likely that this was the event generated by
       * the SDL_WarpMouse below on a previous event. Throw away the event now
       * to avoid infinite recursion.
       */
      if (trigger==PG_TRIGGER_MOVE && !(dx || dy))
	return;  

      /* This will generate a new motion event! */
      SDL_WarpMouse(oldx,oldy);

      /* Translate the mouse wheel into Z motion. Note that this isn't really
       * the correct way to do it, but this works since we're interfacing almost
       * directly with the sdlinput driver. (This is loaded as the first input filter)
       */
      if (trigger == PG_TRIGGER_DOWN && (param->mouse.btn & 8))
	dz = 20;
      if (trigger == PG_TRIGGER_DOWN && (param->mouse.btn & 16))
	dz = -20;    

      scale = gl_get_key_scale();
      dx *= scale;
      dy *= scale;
      dz *= scale;
      
      switch (gl_global.camera_mode) {
	
      case SDLGL_CAMERAMODE_TRANSLATE:
	glTranslatef(dx,dy,dz);
	break;
	
      case SDLGL_CAMERAMODE_ROTATE:
	glRotatef(dy/10.0,1,0,0);
	glRotatef(dx/10.0,0,1,0);
	glRotatef(dz/10.0,0,0,1);
	break;
      }
    }
    
    /* Trap events here */
    return;
  }

  /* Otherwise, pass the event */
  infilter_send(self,trigger,param);
}

/********************************************** Utilities ****/

/* Per-frame processing for motion keys
 */
void gl_process_camera_keys(void) {
  float scale = gl_get_key_scale();

  /* Process camera movement keys */
  switch (gl_global.camera_mode) {
    
  case SDLGL_CAMERAMODE_TRANSLATE:
    if (gl_global.pressed_keys[PGKEY_w])
      glTranslatef(0.0,0.0,5.0*scale);
    if (gl_global.pressed_keys[PGKEY_s])
      glTranslatef(0.0,0.0,-5.0*scale);
    if (gl_global.pressed_keys[PGKEY_DOWN])
      glTranslatef(0.0,5.0*scale,0.0);
    if (gl_global.pressed_keys[PGKEY_UP])
      glTranslatef(0.0,-5.0*scale,0.0);
    if (gl_global.pressed_keys[PGKEY_RIGHT])
      glTranslatef(5.0*scale,0.0,0.0);
    if (gl_global.pressed_keys[PGKEY_LEFT])
      glTranslatef(-5.0*scale,0.0,0.0);
    break;

  case SDLGL_CAMERAMODE_ROTATE:
    if (gl_global.pressed_keys[PGKEY_w])
      glRotatef(0.4*scale,0.0,0.0,1.0);
    if (gl_global.pressed_keys[PGKEY_s])
      glRotatef(-0.4*scale,0.0,0.0,1.0);
    if (gl_global.pressed_keys[PGKEY_UP])
      glRotatef(0.4*scale,1.0,0.0,0.0);
    if (gl_global.pressed_keys[PGKEY_DOWN])
      glRotatef(-0.4*scale,1.0,0.0,0.0);
    if (gl_global.pressed_keys[PGKEY_LEFT])
      glRotatef(0.4*scale,0.0,1.0,0.0);
    if (gl_global.pressed_keys[PGKEY_RIGHT])
      glRotatef(-0.4*scale,0.0,1.0,0.0);
    break;
    
  }
}

/* Allow modifier keys to scale movements 
 */
float gl_get_key_scale(void) {
  if (gl_global.pressed_keys[PGKEY_LSHIFT] || gl_global.pressed_keys[PGKEY_RSHIFT])
    return 0.1;
  if (gl_global.pressed_keys[PGKEY_LCTRL] || gl_global.pressed_keys[PGKEY_RCTRL])
    return 10.0;

  return 1;
}

/********************************************** Input filter registration ****/

struct infilter infilter_sdlgl = {
  accept_trigs: PG_TRIGGER_KEYDOWN | PG_TRIGGER_KEYUP | PG_TRIGGER_CHAR |
                PG_TRIGGER_MOVE | PG_TRIGGER_DOWN | PG_TRIGGER_UP,
  absorb_trigs: PG_TRIGGER_KEYDOWN | PG_TRIGGER_KEYUP | PG_TRIGGER_CHAR |
                PG_TRIGGER_MOVE | PG_TRIGGER_DOWN | PG_TRIGGER_UP,
  handler: &infilter_sdlgl_handler,
};

/* The End */









