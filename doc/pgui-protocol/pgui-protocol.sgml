<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN"[]>

<book id="PicoGUI.Protocol">
 <bookinfo>
  <title>PicoGUI Protocol</title>

  <authorgroup>
   <author>
    <firstname>Dave</firstname>
    <surname>Poirier</surname>
    <affiliation>
     <address>
      <email>instinc@users.sf.net</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>

  <copyright>
   <year>2002</year>
   <holder>Dave Poirier</holder>
  </copyright>

  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>

   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>

   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
  </legalnotice>
  <revhistory>
   <revision>
    <revnumber>0.3</revnumber>
    <date>9 Feb 2002</date>
    <authorinitials>eks</authorinitials>
    <revremark>Added signed data types and PGREQ_[REGOWNER|UNREGOWNER|SETMODE|GETMODE|MKCONTEXT|RMCONTEXT|FOCUS]</revremark>
   </revision>
   <revision>
    <revnumber>0.2</revnumber>
    <date>9 Feb 2002</date>
    <authorinitials>eks</authorinitials>
    <revremark>Added PGREQ_[BATCH|MKFILLSTYLE|MKWAIT|MKPOPUP|REGISTER|SIZETEXT]</revremark>
   </revision>
   <revision>
    <revnumber>0.1</revnumber>
    <date>8 Feb 2002</date>
    <authorinitials>eks</authorinitials>
    <revremark>re-ordered the sections and linked the struct as figures</revremark>
   </revision>
  </revhistory>
 </bookinfo>

 

<toc></toc>

 <chapter id="intro">
  <title>Introduction</title>
  <para>
	This book aims to describe the protocol used to communicate between
	a PicoGUI server and client; the client part is normally implemented
	in the cli_c library.
  </para>
  <para>
	This book is not aimed to be a tutorial to PicoGUI but
	a rather crude technical manual of its communication protocol.
  </para>
 </chapter>
 <chapter id="assumptions">
  <title>Assumptions</title>
  <para>
	It is assumed that the reader have a good general programming
	background, good knowledge of data structures and basic network
	principles.
  </para>
  <para>
	Unless otherwise stated, every value is stored in little-endian
	byte order.
  </para>
  <para>
	The following types are used throughout the document:
  </para>
  <table frame=none><title>data types</title>
  <tgroup cols=2 align=left>
  <tbody>
  <row><entry>char</><entry>signed 8bit value</entry></row>
  <row><entry>s8</><entry>signed 8bit value (same as char)</entry></row>
  <row><entry>u8</><entry>unsigned 8bit value</entry></row>
  <row><entry>s16</><entry>signed 16bit value</entry></row>
  <row><entry>u16</><entry>unsigned 16bit value</entry></row>
  <row><entry>s32</><entry>signed 32bit value</entry></row>
  <row><entry>u32</><entry>unsigned 32bit value</entry></row>
  </tbody>
  </tgroup>
  </table>
  <table frame=none><title>special variables</title>
  <tgroup cols=2 align=left>
  <tbody>
  <row><entry>dummy</><entry>used in various structures to denote bytes of
	padding</entry></row>
  </tbody>
  </tgroup>
  </table>
 </chapter>

<!--..............................................................-->

 <chapter id="ClientServer">
  <title>Client/Server communication</title>
  <para>
  	PicoGUI is a client/server based graphical user interface aimed
	at embedded devices, where the executable size does matter but
	a minimum of flexibility is required.
  </para>
  <para>
	The client application sends requests using <quote>packets</quote>
	which are sent via sockets. Currently supported protocols include
	tcp/ip and unix sockets, each described in its own chapter.
  </para>
  <para>
	A packet is a simple data structure and each request has its own
	format and packet length.  The various packet structures and
	allowed values are defined in the next chapter (see
	<xref linkend="packets">).
  </para>
  <para>
	Establishing a connection with the PicoGUI server is conceived of
	protocol dependant and independant parts.
  </para>

 <sect1 id="prottcp">
  <title>Establishing a TCP/IP connection with PicoGUI</title>
  <para>
	A TCP/IP connection is established by connecting to the tcp port
	PicoGUI is listening to, by default this should be 30450+display.
	A connection to pgserver on display 0 would then be established by
	connecting to port 30450 while a connection to display 1 would be
	done on port 30451.
  </para>
  <para>
	The server may be running on a different host as long as the client is
	able to determine the IP address on which the server is running.
  </para>
 </sect1>

<!--..............................................................-->

 <sect1 id="protunix">
  <title>Establishing a Unix socket connection with PicoGUI</title>
  <para>
	A Unix socket connection is established by opening the
	<quote>/var/tmp/.pgui.X</quote> where X is the display number. As an
	example, if pgserver is running on display 0, the socket name would be
	<quote>/var/tmp/.pgui.0</quote> while a connection for display 1 would
	be done using <quote>/var/tmp/.pgui.1</quote><footnote>
	<para>
	At the time of writing this document, the unix socket layer
	of PicoGUI does not support multiple displays without modifying the
	source code and building separate binaries.  This should be fixed
	pretty soon though, so the chances are that while you are reading 
	this it is already available.  By default at this time the socket
	name is	<quote>/var/tmp/.pgui</quote>.</para></footnote>
  </para>
 </sect1>
 <sect1 id="protindependant"><title>Protocol Independant Initialization</title>
  <para>
	As soon as the connection is established the server will send to the
	client a <quote>pghello</quote> packet.  The client is then able
	to enter the cycle of request->response and may do so by sending
	its first request immediately following the reception of the pghello
	packet.
  </para>

  <sect2 id="pghello">
   <title>pghello</title>
   <para>
	Whenever a connection is established, the server immediately sends
	a <structname>pghello</structname> packet which can be used by the
	client to determine if the server is compatible or not.
   </para>
   <figure><title>struct pghello</title><programlisting>
struct pghello {
  u32 magic;
  u16 protover;
  u16 dummy;
};
   </programlisting></figure>
   <para>
	The <structfield>magic</structfield> id is a value of
	<constant>0x31415926</constant>	identifying a PicoGUI server.
   </para>
   <para>
	The <structfield>protover</structfield> identifies the protocol
	version in use.	The version number is incremented every time a
	change is made to the protocol specifications.  At the time of
	writing this document the latest value was <constant>0x000C</constant>.
   </para>
  </sect2>
 </sect1>
 </chapter>

<!--..............................................................-->

 <chapter id="packets">
  <title>PicoGUI packets</title>
  <para>
	Packets are the basic communication units with a PicoGUI server.
	They can be used to send requests, receive responses and perform
	various actions.
  </para>
  <para>
	You can find the original definitions in
	<filename class=headerfile>picogui/network.h</filename>, or on their
	cvs in
	<filename class=headerfile>pgserver/include/picogui/network.h</filename>.
  </para>

 <sect1 id="twoways">
  <title>Requests and Responses</title>
  <para>
	The client performs action by sending
	<quote><link linkend="requests">requests</link></quote> for
	which the server sends
	<quote><link linkend="responses">responses</link></quote>.
	Note that the server will always send a response packet whether the
	request was valid or not.  The client will be able to determine
	the outcome of a specific request by looking at the response packets
	values.<footnote><para>At the time of writing this document, the server
	does not send individual replies if multiple requests were sent as
	a single packet.</para></footnote>
  </para>
 </sect1>

 <sect1 id="requests">
  <title>Client Requests</title>
  <para>
	Requests are the only packet type allowed from the client.  Each
	request is composed of a common header and optionally by as many bytes
	of data as required.
  </para>
  <para>
	The client proceeds with a request by allocating the required memory
	for the <structname>pgrequest</> structure, filling in the
	<structfield>id</>, <structfield>size</> and <structfield>type</>
	fields, then sending it and the associated data (if any) to the
	server via the network connection.
  </para>
  <figure><title>struct pgrequest</title><programlisting>
struct pgrequest {
  u32 id;
  u32 size;
  u16 type;
  u16 dummy;
};
  </programlisting></figure>
  <para>
	The <structfield>id</structfield> field is a value used by the client
	to match the answers returned for a specific request.  This value does
	not have any particular significance for the server and can be set to
	any value at the discretion of the client.
  </para>
  <para>
	The <structfield>size</structfield> field is used to indicate how many
	bytes of data are attached to the request, excluding the size of the
	common header.
  </para>
  <para>
	The <structfield>type</structfield> is the numerical value identifying
	the request made (see <xref linkend="requesttypes"> for a complete
	listing of valid values).
  </para>

  <!--................................................................-->

  <sect2 id="pgreq-appmsg">
   <title>PGREQ_APPMSG - Send PG_WE_APPMSG to any widget</>
   <programlisting>
type                 : PGREQ_APPMSG
client lib equivalent: pgAppMessage()
additional data      : pgreqd_handlestruct
                       data
   </programlisting>
   <para>
	Send a message to a widget owned by any application.
   </para>
   <para>
	See <xref linkend="pgreqdhandlestruct"> for the format of the
	<structname>pgreqd_handlestruct</> structure.
   </para>
  </sect2>

  <sect2 id="pgreq-attachwidget">
   <title>PGREQ_ATTACHWIDGET - Attach widget</>
   <programlisting>
type                 : PGREQ_ATTACHWIDGET
client lib equivalent: pgAttachWidget()
additional data      : struct pgreqd_attachwidget
   </programlisting>
   <para>
	Attach a widget to a new parent.
   </para>
   <figure><title>struct pgreqd_attachwidget</><programlisting>
struct pgreqd_attachwidget {
  u32 parent;
  u32 widget;
  u16 rship;
  u16 dummy;
};
   </programlisting></figure>
   <para>
	The <structfield>parent</> is the handle of the new parent to set.
   </para>
   <para>
	The <structfield>widget</> is the handle of the widget that needs
	to be attached.
   </para>
   <para>
	The <structfield>rship</> is a <constant>PG_DERIVE_*</> constant
	indicating the new widget's relationship to it's parent
	(see <xref linkend="derivetypes"> for a complete listing).
   </para>
  </sect2>

  <sect2 id="pgreq-batch">
   <title>PGREQ_BATCH - Batch multiple requests</title> 
   <programlisting>
type                 : PGREQ_BATCH
client lib equivalent: none
additional data      : requests
   </programlisting>
   <para>
	This request allows to send a batch of multiple requests that will
	be executed in sequence.  If any command fails, its error code is
	returned and the other commands are ignored.  Only the return value
	fromt he last command is saved.
   </para>
   <para>
	The <structfield>size</> of this request must be set to the sum of
	all the requests combined.
   </para>
  </sect2>

  <sect2 id="pgreq-chcontext">
   <title>PGREQ_CHCONTEXT - Change a handle's context </>
   <programlisting>
type                 : PGREQ_CHCONTEXT
client lib equivalent: pgChangeContext()
additional data      : struct pgreqd_chcontext
   </programlisting>
   <para>
	Change the handle context of an object.
   </para>
   <figure><title>struct pgreqd_chcontext</><programlisting>
struct pgreqd_chcontext {
  u32 handle;
  s16 delta;
  u16 dummy;
};
   </programlisting></figure>
   <para>
	The <structfield>handle</> is the handle of the object for which the
	context must be changed.
   </para>
   <para>
	The <structfield>delta</> is a signed value that will modify the
	current context.  A positive delta value increases the object's
	context, equivalent to adding extra <constant>PGREQ_MKCONTEXT</>
	layers. The delta value may be negative, to 'send' the handle to a
	higher-level context.
   </para>
  </sect2>

  <sect2 id="pgreq-checkevent">
   <title>PGREQ_CHECKEVENT - Return number of queued events</>
   <programlisting>
type                 : PGREQ_CHECKEVENT
client lib equivalent: pgCheckEvent()
additional data      : none
   </programlisting>
   <para>
	Check the number of pending events.
   </para>
   <para>
	The PicoGUI server keeps a ring buffer of waiting events for each
	client connected to it. This request returns the number of events
	waiting in this buffer. Note that this buffer is usually relatively
	small. At the time of writing this, it is set to hold 16 events.
	If the buffer is full, old events will be discarded.
   </para>
   <para>
	You can use this request if, for some reason, you need to poll
	PicoGUI events instead of waiting for them. In the middle of a long
	operation, for example, you may wish to periodically check if the
	user clicks a cancel button. If this request indicates that there are
	events waiting, a <constant>PGREQ_WAIT</> request will immediately
	return the oldest queued event.
   </para>
  </sect2>

  <sect2 id="pgreq-createwidget">
   <title>PGREQ_CREATEWIDGET - Create a widget</title> 
   <programlisting>
type                 : PGREQ_CREATEWIDGET
client lib equivalent: pgCreateWidget()
additional data      : struct pgreqd_createwidget
   </programlisting>
   <para>
	Create a widget, but does not attach it to the parent widget. You can
	still set the widget's properties and attach child widgets to this
	one, but the widget cannot be drawn until a
	<constant>PGREQ_ATTACHWIDGET</constant> request successfully
	completed.
   </para>
   <figure><title>struct pgreqd_createwidget</><programlisting>
struct pgreqd_createwidget {
   u16 type;
   u16 dummy;
};
   </programlisting></figure>
   <para>
	Where <structfield>type</> is a type defined in
	<xref linkend="widgettypes">.
   </para>
  </sect2>

  <sect2 id="pgreq-drivermsg">
   <title>PGREQ_DRIVERMSG - Send a message to all drivers</>
   <programlisting>
type                 : PGREQ_DRIVERMSG
client lib equivalent: pgDriverMessage()
additional data      : struct pgreqd_drivermsg
   </programlisting>
   <para>
	This command can send 'extra' commands that may be
	hardware-specific, like beeps, cursor blanking, and backlight
	control.
   </para>
   <figure><title>struct pgreqd_drivermsg</><programlisting>
struct pgreqd_drivermsg {
  u32 message;
  u32 param;
};
   </programlisting></figure>
   <para>
	Where <structfield>message</> is a <constant>PGDM_*</> constant
	specying the message type and <structfield>param</> is the
	associated data for the specific message type sent (see
	<xref linkend="pgdmtypes"> for a complete listing).
   </para>
  </sect2>

  <sect2 id="pgreq-dup">
   <title>PGREQ_DUP - Duplicate an object</>
   <programlisting>
type                 : PGREQ_DUP
client lib equivalent: pgDup()
additional data      : struct pgreqd_handlestruct
   </programlisting>
   <para>
	Duplicate an object that has a handle. See
	<xref linkend="pgreqdhandlestruct"> for
	<structname>pgreqd_handlestruct</> structure format.
   </para>
   <para>
	Some objects simply can't be duplicated: For example, it would not
	make sense to duplicate a widget, driver, or theme.
	<footnote><para>At the time of writing this, the only object type
	for which duplication is implemented is the string object.</></>
   </para>
  </sect2>

  <sect2 id="pgreq-findthobj">
   <title>PGREQ_FINDTHOBJ - Find theme object by name</>
   <programlisting>
type                 : PGREQ_FINDTHOBJ
client lib equivalent: pgFindThemeObject()
additional data      : data (name)
   </programlisting>
   <para>
	Find a theme object's ID given its name.  Theme objects defined as
	custom are assigned an ID automatically at load time. These objects
	can be found with this request as long as each is assigned a unique
	name property.
   </para>
   <para>
	The <structfield>data</> is the name of the property to search for.
   </para>
  </sect2>

  <sect2 id="pgreq-findwidget">
   <title>PGREQ_FINDWIDGET - Get widget handle by name</>
   <programlisting>
type                 : PGREQ_FINDWIDGET
client lib equivalent: pgFindWidget()
additional data      : data (name)
   </programlisting>
   <para>
	Search for a widget by its PG_WP_NAME property.
   </para>
   <para>
	Every widget can be given a name by setting it's PG_WP_NAME property
	to a string handle. This request can search for a widget's handle
	based on this name. Note that this request will search all widgets,
	even those not owned by the client.
   </para>
  </sect2>

  <sect2 id="pgreq-focus">
   <title>PGREQ_FOCUS - Forces focus to a specified widget</>
   <programlisting>
type                 : PGREQ_FOCUS
client lib equivalent: pgFocus()
additional data      : struct pgreqd_handlestruct
   </programlisting>
   <para>
	Give a widget the keyboard focus.
   </para>
   <para>
	See <xref linkend="pgreqdhandlestruct"> for more info about
	<structname>pgreqd_handlestruct</>.
   </para>
  </sect2>

  <sect2 id="pgreq-free">
   <title>PGREQ_FREE - Free a handle</title> 
   <programlisting>
type                 : PGREQ_FREE
client lib equivalent: pgDelete()
additional data      : struct pgreqd_handlestruct
   </programlisting>
   <para>
	Free the handle specified and delete its associated object.
   </para>
   <figure id="pgreqdhandlestruct"><title>struct pgreqd_handlestruct</title><programlisting>
struct pgreqd_handlestruct {
  u32 h;
};
   </programlisting></figure>
   <para>
	Where <structfield>h</> is the handle to free.
   </para>
  </sect2>

  <sect2 id="pgreq-get">
   <title>PGREQ_GET - Get a widget's property</title> 
   <programlisting>
type                 : PGREQ_GET
client lib equivalent: pgGetWidget()
additional data      : struct pgreqd_get
   </programlisting>
   <para>
	Get a widget property.
   </para>
   <figure><title>struct pgreqd_get</><programlisting>
struct pgreqd_get {
  u32 widget;
  u16 property; 
  u16 dummy;
};
   </programlisting></figure>
   <para>
	The <structfield>widget</> is the handle of the widget to get the
	property from.
   </para>
   <para>
	The <structfield>property</> is a property identifier (see
	<xref linkend="propertytypes"> for a complete listing).
   </para>
  </sect2>

  <sect2 id="pgreq-getfstyle">
   <title>PGREQ_GETFSTYLE - Get information on a font</>
   <programlisting>
type                 : PGREQ_GETFSTYLE
client lib equivalent: pgGetFontStyle()
additional data      : struct pgreqd_getfstyle
   </programlisting>
   <para>
	Get information about a font style
   </para>
   <figure><title>struct pgreqd_getfstyle</><programlisting>
struct pgreqd_getfstyle {
  u16 index;
  u16 dummy;
};
   </programlisting></figure>
   <para>
	The <structfield>index</> is a zero-based index to select a font style
	in the order that the were compiled or loaded into pgserver.
   </para>
  </sect2>

  <sect2 id="pgreq-getinactive">
   <title>PGREQ_GETINACTIVE - Get miliseconds of inactivity</>
   <programlisting>
type                 : PGREQ_GETINACTIVE
client lib equivalent: pgGetInactivity()
additional data      : none
   </programlisting>
   <para>
	Get the number of miliseconds of inactivity.
   </para>
  </sect2>

  <sect2 id="pgreq-getmode">
   <title>PGREQ_GETMODE - Get video mode information</>
   <programlisting>
type                 : PGREQ_GETMODE
client lib equivalent: pgGetVideoMode()
additional data      : none
   </programlisting>
   <para>
	Get information about the current video mode.
   </para>
  </sect2>

  <sect2 id="pgreq-getpayload">
   <title>PGREQ_GETPAYLOAD - Get the payload of an object </>
   <programlisting>
type                 : PGREQ_GETPAYLOAD
client lib equivalent: pgGetPayload()
additional data      : struct pgreqd_handlestruct
   </programlisting>
   <para>
	Get an object's payload.  See <xref linkend="pgreq-setpayload"> for
	more information.
   </para>
  </sect2>

  <sect2 id="pgreq-getstring">
   <title>PGREQ_GETSTRING - Return a string data</>
   <programlisting>
type                 : PGREQ_GETSTRING
client lib equivalent: pgGetString()
additional data      : struct pgreqd_handlestruct
   </programlisting>
   <para>
	Get the contents of a string handle.  See
	<xref linkend="pgreqdhandlestruct"> for
	<structname>pgreqd_handlestruct</> format.
   </para>
  </sect2>

  <sect2 id="pgreq-in-key">
   <title>PGREQ_IN_KEY - Dispatch keyboard input</title> 
   <programlisting>
type                 : PGREQ_IN_KEY
client lib equivalent: pgDispatchEvent()
additional data      : struct pgreqd_in_key
   </programlisting>
   <para>
	Dispatch a keyboard input.
   </para>
   <figure><title>struct pgreqd_in_key</><programlisting>
struct pgreqd_in_key {
  u32 type;
  u16 key;
  u16 mods;
};
   </programlisting></figure>
   <para>
	The <structfield>type</> is a TRIGGER_* constant (see
	<xref linkend="triggertypes"> for a complete listing).
   </para>
   <para>
	The <structfield>mods</> is a bitmask of the currently active
	modifiers (see <xref linkend="pgmod"> for a complete
	listing).
   </para>
   <para>
	The <structfield>key</> value varies depending on the type of event
	generated.
   </para>
   <para>
	When generating a PG_TRIGGER_CHAR, <structfield>key</> is a unicode
	UTF-16 character.
   </para>
   <para>
	When generating a PG_TRIGGER_KEYUP or PG_TRIGGER_KEYDOWN event, the
	value is a PGKEY (see <xref linkend="pgkeys"> for a complete
	listing).
   </para>
   <para>
	<emphasis>IMPORTANT NOTE:</> this protocol packet will change in the
	next version and will be incompatible.
   </para>
  </sect2>

  <sect2 id="pgreq-in-point">
   <title>PGREQ_IN_POINT - Dispatch a pointing device input</title> 
   <programlisting>
type                 : PGREQ_IN_POINT
client lib equivalent: pgDispatchEvent()
additional data      : struct pgreqd_in_point
   </programlisting>
   <para>
 	Dispatch a pointing device input
   </para>
   <figure><title>struct pgreqd_in_point</><programlisting>
struct pgreqd_in_point {
  u32 type;
  u16 x;
  u16 y;
  u16 btn;
  u16 dummy;
};
   </programlisting></figure>
   <para>
	The <structfield>type</> is a TRIGGER_* constant (see
	<xref linkend="triggertypes"> for a complete listing).
   </para>
   <para>
	The <structfield>x</> and <structfield>y</> are the absolute
	coordinates of the pointer.
   </para>
   <para>
	The <structfield>btn</> is a bitmask of the buttons state.
   </para>
  </sect2>

  <sect2 id="pgreq-loaddriver">
   <title>PGREQ_LOADDRIVER - Load input/misc driver</>
   <programlisting>
type                 : PGREQ_LOADDRIVER
client lib equivalent: pgLoadDriver()
additional data      : data
   </programlisting>
   <para>
	Load a named driver.  The name is specified as the
	<structfield>data</> argument.
   </para>
  </sect2>

  <sect2 id="pgreq-mkarray">
   <title>PGREQ_MKARRAY - Make an array</>
   <programlisting>
type                 : PGREQ_MKARRAY
client lib equivalent: pgNewArray()
additional data      : data
   </programlisting>
   <para>
	Create a new array object.  Each array entry is 32bit and must be sent
	to the server in the network byte order.  The <structfield>size</> of
	the request will set the size of the array.
   </para>
  </sect2>

  <sect2 id="pgreq-mkbitmap">
   <title>PGREQ_MKBITMAP - Create a bitmap</title> 
   <programlisting>
type                 : PGREQ_MKBITMAP
client lib equivalent: pgCreateBitmap
additional data      : struct pgreqd_newbitmap
   </programlisting>
   <para>
	Create a new bitmap object.
   </para>
   <figure><title>struct pgreqd_newbitmap</><programlisting>
struct pgreqd_newbitmap {
  u16 width;
  u16 height;
};
   </programlisting></figure>
   <para>
	Where <structfield>width</> and <structfield>height</> for the new
	image are specified in pixels.
   </para>
  </sect2>

  <sect2 id="pgreq-mkcontext">
   <title>PGREQ_MKCONTEXT - Enter a new context</>
   <programlisting>
type                 : PGREQ_MKCONTEXT
client lib equivalent: pgEnterContext()
additional data      : none
   </programlisting>
   <para>
	Enter a new context.
   </para>
   <para>
	PicoGUI uses a context system, similar to a variable's scope in C.
	Whenever the program leaves a context, all objects created while in
	that context are deleted. No memory is used by creating a context,
	and they can be nested a very large number of times.
   </para>
  </sect2>

  <sect2 id="pgreq-mkfillstyle">
   <title>PGREQ_MKFILLSTYLE - Load a fill style</title>
   <programlisting>
type                 : PGREQ_MKFILLSTYLE
client lib equivalent: none
additional data      : raw fillstyle bytecode
   </programlisting>
   <para>
	This request is used by the compiled theme and should not be used by
	the client.  More information about raw fillstyle bytecode can be
	found in <filename>pgserver/include/picogui/theme.h</>
   </para>
  </sect2>

  <sect2 id="pgreq-mkfont">
   <title>PGREQ_MKFONT - Make a font descriptor</title> 
   <programlisting>
type                 : PGREQ_MKFONT
client lib equivalent: pgNewFont()
additional data      : pgreqd_mkfont
   </programlisting>
   <para>
	Create a new font object using the specified font name and properties.
   </para>
   <figure><title>struct pgreqd_mkfont</><programlisting>
struct pgreqd_mkfont {
  char name[40];
  u32 style;
  u16 size;
  u16 dummy;
};	
   </programlisting></figure>
   <para>
	Where <structfield>name</> is the name of the font to search for. It
	is possible to specify no specific font name by using 
	<literal>name[0]=0</>.
   </para>
   <para>
	The <structfield>style</> value is zero or more PG_FSTYLE_* flags
	or'ed together (see <xref linkend="fontstyles"> for a complete
	listing).
   </para>
   <para>
	The <structfield>size</> or height in pixels of the font to search
	for, or zero for any.
   </para>
  </sect2>

  <sect2 id="pgreq-mkpopup">
   <title>PGREQ_MKPOPUP - Create a Popup root widget</title>
   <programlisting>
type                 : PGREQ_MKPOPUP
client lib equivalent: pgNewPopup() and pgNewPopupAt()
additional data      : struct pgreqd_mkpopup
   </programlisting>
   <para>
	Create a popup root widget.
   </para>
   <figure><title>struct pgreqd_mkpopup</><programlisting>
struct pgreqd_mkpopup {
  u16 x;
  u16 y;
  u16 w;
  u16 h;
};	
   </programlisting></figure>
   <para>
	The <structfield>x</> and <structfield>y</> are absolute coordinate
	of the top left corner of the root widget to create.  They may be
	set to a <constant>PG_POPUP_*</> constant.
   </para>
   <para>
	The <structfield>w</> and <structfield>h</> are respectively the
	width and height of the root widget. It is preferable to set those
	value to 0 to have them automatically computed, the application should
	assume as little as possible about the physical screen properties.
   </para>
   <table frame=none pgwide=1><title>PG_POPUP values</title>
   <tgroup cols=3 align=left>
   <colspec colwidth="45*">
   <colspec colwidth="10*">
   <colspec colwidth="45*">
   <tbody>
   <row><entry>PG_POPUP_CENTER</><entry>-1</><entry>Centered on screen</></>
   <row><entry>PG_POPUP_ATCURSOR</><entry>-2</><entry>At the pointing device's
   cursor. If the cursor is over a button or menuitem, the popup snaps to its
   edge automatically</></>
   </tbody>
   </tgroup>
   </table>
  </sect2>

  <sect2 id="pgreq-mkstring">
   <title>PGREQ_MKSTRING - Create a string</title>
   <programlisting>
type                 : PGREQ_MKSTRING
client lib equivalent: pgNewString()
additional data      : string
   </programlisting>
   <para>
	Create a new string object.
   </para>
   <para>
	The string may be of variable length.  If the string is not
	0-terminated the server will terminate it at the end of the packet.
   </para>
  </sect2>

  <sect2 id="pgreq-mktheme">
   <title>PGREQ_MKTHEME - Load a compiled theme</title>
   <programlisting>
type                 : PGREQ_MKTHEME
client lib equivalent: pgLoadTheme()
additional data      : compiled theme data
   </programlisting>
   <para>
	Load a compiled theme and return the handle for it.
   </para>
  </sect2>

  <sect2 id="pgreq-mkwidget">
   <title>PGREQ_MKWIDGET - Make a new widget</title> 
   <programlisting>
type                 : PGREQ_MKWIDGET
client lib equivalent: pgNewWidget()
additional data      : struct pgreqd_mkwidget()
   </programlisting>
   <para>
	Create a new widget, derived from a parent widget.
   </para>
   <figure><title>struct pgreqd_mkwidget</><programlisting>
struct pgreqd_mkwidget {
  u16 rship;
  u16 type;
  u32 parent;
};
   </programlisting></figure>
   <para>
	The <structfield>rship</> is a <constant>PG_DERIVE_*</> constant
	indicating the new widget's relationship to it's parent
	(see <xref linkend="derivetypes"> for a complete listing).
   </para>
   <para>
	The <structfield>type</> is a <constant>PG_WIDGET_*</> constant for
	the widget type (see <xref linkend="widgettypes"> for a complete listing).
   </para>
   <para>
	The <structfield>parent</> is the handle of the parent widget.
   </para>
  </sect2>

  <sect2 id="pgreq-newbitmap">
   <title>PGREQ_NEWBITMAP - Create a blank bitmap</>
   <programlisting>
type                 : PGREQ_NEWBITMAP
client lib equivalent: pgNewbitmap()
additional data      : struct pgreqd_newbitmap
                       image data
   </programlisting>
   <para>
	Create a new bitmap object from existing data.  This request is
	similar to <constant>PGREQ_MKBITMAP</>
	(<xref linkend="pgreq-mkbitmap">) with the difference that the
	initial image data is provided.
   </para>
   <para>
	The image data <emphasis>must</> follow immediately after the
	<structname>pgrequest</> and <structname>pgreqd_newbitmap</>
	structures.  The data is sent as found in the image file, that is
	JPEG, GIF, PNG, BMP, etc.
   </para>
   <para>
   </para>
  </sect2>

  <sect2 id="pgreq-ping">
   <title>PGREQ_PING - Ping request</title>
   <programlisting>
type                 : PGREQ_PING
client lib equivalent: none
additional data      : none
   </programlisting>
   <para>
	return <constant>success</> if the server connection is ok.
   </para>
  </sect2>

  <sect2 id="pgreq-register">
   <title>PGREQ_REGISTER - Register an application</title> 
   <programlisting>
type                 : PGREQ_REGISTER
client lib equivalent: pgRegisterApp()
additional data      : struct pgreqd_register
   </programlisting>
   <para>
	Create a root window of an application.
   </para>
   <figure><title>struct pgreqd_register</><programlisting>
struct pgreqd_register {
  u32 name;
  u16 type;
  u16 dummy;
};
   </programlisting></figure>
   <para>
	The <structfield>name</> is the handle of the string to use as the
	application name.  If applicable, it will be displayed in its panelbar.
   </para>
   <para>
	The <structfield>type</> is a <constant>PG_APP_*</> constant.
   </para>
   <table frame=none pgwide=1><title>PG_APP values</title>
   <tgroup cols=3 align=left>
   <colspec colwidth="45*">
   <colspec colwidth="10*">
   <colspec colwidth="45*">
   <tbody>
   <row><entry>PG_APP_NORMAL</><entry>1</><entry>Normal application assigned
   a resizeable window</></>
   <row><entry>PG_APP_TOOLBAR</><entry>2</><entry>Toolbar application using a
   fixed width window without panelbar</></>
   </tbody>
   </tgroup>
   </table>
  </sect2>

  <sect2 id="pgreq-regowner">
   <title>PGREQ_REGOWNER - Get exclusive privileges </>
   <programlisting>
type                 : PGREQ_REGOWNER
client lib equivalent: pgRegisterOwner()
additional data      : struct pgreqd_regowner
   </programlisting>
   <para>
	Register exclusive access to a resouce.
   <para>
   <figure><title>struct pgreqd_regowner</><programlisting>
struct pgreqd_regowner {
  u16 res;
};
   </programlisting></figure>
   <para>
	Where <structfield>res</> is the <constant>PG_OWN_*</> constant value
	of the resource to get exclusive privileges of.
   </para>
   <table frame=none pgwide=1 id="pgowntypes"><title>PG_OWN values</>
   <tgroup cols=3 align=left>
   <colspec colwidth="45*">
   <colspec colwidth="10*">
   <colspec colwidth="45*">
   <tbody>
   <row><entry>PG_OWN_KEYBOARD</><entry>1</><entry>Exclusive access to the keyboard</></>
   <row><entry>PG_OWN_POINTER</><entry>2</><entry>Exclusive access to the pointer</></>
   <row><entry>PG_OWN_SYSEVENTS</><entry>3</><entry>Receive system events like app open/close, click on background, etc.</></>
   <row><entry>PG_OWN_DISPLAY</><entry>4</><entry>Exclusive access to the display via <constant>PGREQ_RENDER</> requests</></>
   </tbody>
   </tgroup>
   </table>
   <para>
	<emphasis>NOTE:</> In the next protocol version the <structname>pgreqd_regowner</> structure will be padded to 32bits.
   </para>

  <sect2 id="pgreq-render">
   <title>PGREQ_RENDER - Render a gropnode to a bitmap</>
   <programlisting>
type                 : PGREQ_RENDER
client lib equivalent: pgRender()
additional data      : struct pgreqd_render
                       gropnode data
   </programlisting>
   <para>
	Render a gropnode to a bitmap
   </para>
   <figure><title>struct pgreqd_render</><programlisting>
struct pgreqd_render {
  u32 dest;
  u32 groptype;
};
   </programlisting></figure>
   <para>
	The <structfield>dest</> is a bitmap handle to render to.
	Alternatively, if the app has registered exclusive display access
	this can be zero to draw directly to the display.
   </para>
   <para>
	The <structfield>groptype</> is a <constant>PG_GROP_*</> constant
	indicating the type of gropnode (see below for a list of valid values).
   </para>
   <para>
	Immediately following the <structfield>groptype</> the gropnode parameters
	should follow.
   </para>
  </sect2>

  <sect2 id="pgreq-rmcontext">
   <title>PGREQ_RMCONTEXT - Clean up and kill a context </>
   <programlisting>
type                 : PGREQ_RMCONTEXT
client lib equivalent: pgLeaveContext()
additional data      : none
   </programlisting>
   <para>
	Leave a context.
   </para>
   <para>
	When leaving a context, all objects created within it are deleted.
   </para>
  </sect2>

  <sect2 id="pgreq-set">
   <title>PGREQ_SET - Set a widget's properties</title> 
   <programlisting>
type                 : PGREQ_SET
client lib equivalent: pgSetWidget()
additional data      : struct pgreqd_set
   </programlisting>
   <para>
	Set the properties of a widget.
   </para>
   <figure><title>struct pgreqd_set</><programlisting>
struct pgreqd_set {
  u32 widget;
  u32 glob;
  u16 property;
  u16 dummy;
};	
   </programlisting></figure>
   <para>
	The <structfield>widget</> is the handle of the widget for which the
	propertie needs to be set.
   </para>
   <para>
	The <structfield>glob</> is the new value to assign to this property.
   </para>
   <para>
	The <structfield>property</> is a property identifier (see
	<xref linkend="propertytypes"> for a complete listing).
   </para>
  </sect2>

  <sect2 id="pgreq-setinactive">
   <title>PGREQ_SETINACTIVE - Set miliseconds of inactivity</>
   <programlisting>
type                 : PGREQ_SETINACTIVE
client lib equivalent: pgSetInactivity()
additional data      : struct pgreqd_setinactive
   </programlisting>
   <para>
	Set the number of milisecond of inactivity.
   </para>
   <figure><title>struct pgreqd_setinactive</><programlisting>
struct pgreqd_setinactive {
  u32 time;
};
   </programlisting></figure>
   <para>
	Where <structfield>time</> is the number of miliseconds to use as
	timer delta.
   </para>
  </sect2>

  <sect2 id="pgreq-setmode">
   <title>PGREQ_SETMODE - Set video mode/depth/rotation</>
   <programlisting>
type                 : PGREQ_SETMODE
client lib equivalent: pgSetVideoMode()
additional data      : struct pgreqd_setmode
   </programlisting>
   <para>
	Change video mode/depth/rotation at runtime.
   </para>
   <figure><title>struct pgreqd_setmode</><programlisting>
struct pgreqd_setmode {
  u16 xres;
  u16 yres;
  u16 bpp;
  u16 flagmode;
  u32 flags;
};
   </programlisting></figure>
   <para>
 	The <structfield>xres</> and <structfield>yres</> indicate the width
	and height, respectively, of the video mode to use.  A value of 0 for
	either of them means to not change the current value.
   </para>
   <para>
	The <structfield>bpp</> indicates the depth to use (bits per pixel).
	A value of 0 indicates to the server to keep the current video mode
	depth.
   </para>
   <para>
	The <structfield>flagmode</> is a <constant>PG_FM_*</> constant
	specifying how to combine flags with the current video flags
	(see <xref linkend="flagmodes"> below).
   </para>
   <para>
	The <structfield>flags</> specifies extra optional features that may
	be present in the video driver. Unsupported flags are ignored. It can
	be zero or more <constant>PG_VID_*</> values or'ed together
	(see <xref linkend="videoflags"> below).
   </para>
   <table id="flagmodes" frame=none pgwide=1>
   <title>PG_FM values</title>
   <tgroup cols=3 align=left>
   <colspec colwidth="45*">
   <colspec colwidth="10*">
   <colspec colwidth="45*">
   <tbody>
   <row><entry>PG_FM_SET</><entry>0</><entry>Sets all flags to the specified value</></>
   <row><entry>PG_FM_ON</><entry>1</><entry>Turns on specified flags</></>
   <row><entry>PG_FM_OFF</><entry>2</><entry>Turns off specified flags</></>
   <row><entry>PG_FM_TOGGLE</><entry>3</><entry>Toggles specified flags</></>
   </tbody>
   </tgroup>
   </table>
   <para>
   </para>
   <table id="videoflags" frame=none pgwide=1>
   <title>PG_VID values</title>
   <tgroup cols=3 align=left>
   <colspec colwidth="45*">
   <colspec colwidth="10*">
   <colspec colwidth="45*">
   <tbody>
   <row><entry>PG_VID_FULLSCREEN</><entry>0x0001</><entry>Deprecated</></>
   <row><entry>PG_VID_DOUBLEBUFFER</><entry>0x0002</><entry>Deprecated</></>
   <row><entry>PG_VID_ROTATE90</><entry>0x0004</><entry>Rotate the display 90 degree clockwise</></>
   <row><entry>PG_VID_ROTATE180</><entry>0x0008</><entry>Rotate the display 180 degree clockwise</></>
   <row><entry>PG_VID_ROTATE270</><entry>0x0010</><entry>Rotate the display 270 degree clockwise</></>
   </tbody>
   </tgroup>
   </table>
   <para>
	note: the <constant>PG_VID_ROTATE*</> flags are mutually exclusive.
   </para>
  </sect2>

  <sect2 id="pgreq-setpayload">
   <title>PGREQ_SETPAYLOAD - Set an object's payload</>
   <programlisting>
type                 : PGREQ_SETPAYLOAD
client lib equivalent: pgSetPayload()
additional data      : struct pgreqd_setpayload
   </programlisting>
   <para>
	Set an object's payload.  The "payload" is a client-defined chunk of
	data attatched to any object that has a handle. Some good uses for
	this are assigning numerical values to buttons, or even creating a
	linked list of objects by storing a handle in the payload. It is
	usually possible for the client to store pointers in the payload, but
	this is not recommended, for two reasons:
   </para>
   <itemizedlist mark=opencircle>
   <listitem>
   <para>
	If the pgserver is buggy or compromised, the client is vulnerable to
	crashes or data corruption.
   </para>
   </listitem>
   <listitem>
   <para>
	If the client-side architecture uses pointers of more than 32 bits,
	it will not work.
   </para>
   </listitem>
   </itemizedlist>
   <figure><title>struct pgreqd_setpayload</><programlisting>
struct pgreqd_setpayload {
  u32 h;
  u32 payload;
};
   </programlisting></figure>
   <para>
	Where <structfield>payload</> is the 32bit value to assign as payload
	and <structfield>h</> is the handle of the object to assign the
	payload to.
   </para>
  </sect2>

  <sect2 id="pgreq-sizebitmap">
   <title>PGREQ_SIZEBITMAP - Find the size of a bitmap</>
   <programlisting>
type                 : PGREQ_SIZEBITMAP
client lib equivalent: pgSizeBitmap()
additional data      : struct pgreqd_handlestruct
   </programlisting>
   <para>
	Find the width and height of a bitmap matching the provided handle
	of a valid PicoGUI bitmap object.
   </para>
   <para>
	See <xref linkend="pgreqdhandlestruct"> for the
	<structname>pgreqd_handlestruct</> structure format.
   </para>
  </sect2>

  <sect2 id="pgreq-sizetext">
   <title>PGREQ_SIZETEXT - Find the size of text</title> 
   <programlisting>
type                 : PGREQ_SIZETEXT
client lib equivalent: pgSizeText()
additional data      : struct pgreqd_sizetext
   </programlisting>
   <para>
	Measure the length and height of a string of text.
   </para>
   <figure><title>struct pgreqd_sizetext</><programlisting>
struct pgreqd_sizetext {
  u32 text;
  u32 font;
};
   </programlisting></figure>
   <para>
	Where <structfield>text</> and <structfield>font</> are handles of the
	string and font to use respectively.
   </para>
  </sect2>

  <sect2 id="pgreq-thlookup">
   <title>PGREQ_THLOOKUP - Perform a theme lookup</>
   <programlisting>
type                 : PGREQ_THLOOKUP
client lib equivalent: pgThemeLookup()
additional data      : struct pgreqd_thlookup
   </programlisting>
   <para>
	Retrieve a theme property.
   </para>
   <figure><title>struct pgreqd_thlookup</><programlisting>
truct pgreqd_thlookup {
  u16 object;
  u16 property;
};
   </programlisting></figure>
   <para>
	The <structfield>object</> is a <constant>PGTH_O_*</> theme object
	constant (see <xref linkend="pgthotypes"> for a complete listing).
   </para>
   <para>
	The <structfield>property</> is a <constant>PGTH_P_*</> theme
	property constant (see <xref linkend="pgthptypes"> for a complete
	listing).
   </para>
  </sect2>

  <sect2 id="pgreq-traversewgt">
   <title>PGREQ_TRAVERSEWGT - Find widgets after this one</>
   <programlisting>
type                 : PGREQ_TRAVERSEWGT
client lib equivalent: pgTraverseWidget()
additional data      : struct pgreqd_traversewgt
   </programlisting>
   <para>
	Finds a widget in relation to another widget.
   </para>
   <figure><title>struct pgreqd_traversewgt</><programlisting>
struct pgreqd_traversewgt {
  u32 widget;
  u16 direction;
  u16 count;
};  
   </programlisting></figure>
   <para>
	The <structfield>widget</> is the handle of the widget referenced.
   </para>
   <para>
	The <structfield>direction</> is the direction to traverse
	specified with a <constant>PG_TRAVERSE_*</> constant (see
	<xref linkend="pgtraversetypes"> for a complete listing).
   </para>
   <para>
	The <structfield>count</> is the number of steps to take in that
	direction.
   </para>
   <table frame=none pgwide=1 id="pgtraversetypes"><title>PG_TRAVERSE values</>
   <tgroup cols=3 align=left>
   <colspec colwidth="45*">
   <colspec colwidth="10*">
   <colspec colwidth="45*">
   <tbody>
   <row><entry>PG_TRAVERSE_CHILDREN</><entry>1</><entry>Starting with this widget's first child, traverse forward</></>
   <row><entry>PG_TRAVERSE_FORWARD</><entry>2</><entry></></>
   <row><entry>PG_TRAVERSE_BACKWARD</><entry>3</><entry>Going backwards is much slower than going forward right now</></>
   <row><entry>PG_TRAVERSE_CONTAINER</><entry>4</><entry><structfield>count</> is the number of container levels to traverse up</></>
   </tbody>
   </tgroup>
   </table>
  </sect2>

  <sect2 id="pgreq-unregowner">
   <title>PGREQ_UNREGOWNER - Give up exclusive privileges</>
   <programlisting>
type                 : PGREQ_UNREGOWNER
client lib equivalent: pgUnregisterOwner()
additional data      : struct pgreqd_regowner
   </programlisting>
   <para>
	Unregister exclusive access to a resouce.  An error will be returned
	if the client does not already own the specified resource.
   </para>
   <para>
	See also <xref linkend="pgreq-regowner"> and
	<xref linkend="pgowntypes">.
   </para>
  </sect2>

  <sect2 id="pgreq-update">
   <title>PGREQ_UPDATE - Update the screen</title> 
   <programlisting>
type                 : PGREQ_UPDATE
client lib equivalent: pgUpdate()
additional data      : none
   </programlisting>
   <para>
	Redraw portions of the screen if necessary. This forces all unsent
	packets to be flushed to the server, and instructs the server to
	draw changed areas of the screen.
   </para>
  </sect2>

  <sect2 id="pgreq-updatepart">
   <title>PGREQ_UPDATEPART - Update a subtree of widgets</>
   <programlisting>
type                 : PGREQ_UPDATEPART
client lib equivalent: pgSubUpdate()
additional data      : pgreqd_handlestruct
   </programlisting>
   <para>
	Update a subsection of the screen.
   </para>
   <para>
	The given widget and all other widgets contained within it are redrawn if necessary. The request buffer is flushed and the section is redrawn independantly and immediately.
   </para>
   <para>
	This function is recommended for animation. Areas of the screen other than the specified widget and its children are never updated, and SubUpdates can occur in toolbars even while a popup dialog is onscreen.
   </para>
  </sect2>

  <sect2 id="pgreq-wait">
   <title>PGREQ_WAIT - Wait for an event</title> 
   <programlisting>
type                 : PGREQ_WAIT
client lib equivalent: pgEvent()
additional data      : none
   </programlisting>
   <para>
	Indicate to the server that the client is waiting for an event, if
	any event is available it will be sent as a response immediately,
	otherwise the client is placed in a waiting queue.
   </para>
   <para>
	If any request is received by the server after a 
	<constant>PGREQ_MKWAIT</>, the client will be removed from the wait
	queue and the new request wil be processed. In the event where the
	new request would be a <constant>PGREQ_MKWAIT</>, the client is sent
	back in the waiting queue after discarding the previous request.
   </para>
   <para>
 	<emphasis>IMPORTANT NOTE:</> The behaviour of this request will
	change in a future implementation of this protocol, the client should
	for now restrict itself from sending any other request after a
	<constant>PGREQ_MKWAIT</> is sent.
   </para>
  </sect2>

  <sect2 id="pgreq-writeto">
   <title>PGREQ_WRITETO - Write data to a widget </>
   <programlisting>
type                 : PGREQ_WRITETO
client lib equivalent: pgWriteData()
additional data      : pgreqd_handlestruct
                       data
   </programlisting>
   <para>
	Write a chunk of widget-defined data to a widget. For example, this
	can be used to send text to a terminal widget or commands to a canvas
	widget.
   </para>
   <para>
	See <xref linkend="pgreqdhandlestruct"> for the
	<constant>pgreqd_handlestruct</> format.
   </para>
  </sect2>

 </sect1>

 <sect1 id="responses">
  <title>Server Responses</title>
  <para>
	
  </para>
 </sect1>
 </chapter>

 <appendix id="gropnodetypes">
  <title>Gropnode Types</title>
  <table id="groptypes" frame=none pgwide=1>
  <title>PG_GROP values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PG_GROP_RECT</><entry>0x00</><entry></></>
  <row><entry>PG_GROP_FRAME</><entry>0x10</><entry></></>
  <row><entry>PG_GROP_SLAB</><entry>0x20</><entry></></>
  <row><entry>PG_GROP_BAR</><entry>0x30</><entry></></>
  <row><entry>PG_GROP_PIXEL</><entry>0x40</><entry></></>
  <row><entry>PG_GROP_LINE</><entry>0x50</><entry></></>
  <row><entry>PG_GROP_ELLIPSE</><entry>0x60</><entry></></>
  <row><entry>PG_GROP_FELLIPSE</><entry>0x70</><entry></></>
  <row><entry>PG_GROP_TEXT</><entry>0x04</><entry>Param: string</></>
  <row><entry>PG_GROP_BITMAP</><entry>0x14</><entry>Param: bitmap</></>
  <row><entry>PG_GROP_TILEBITMAP</><entry>0x24</><entry>Param: bitmap</></>
  <row><entry>PG_GROP_FPOLYGON</><entry>0x34</><entry>Param: array</></>
  <row><entry>PG_GROP_GRADIENT</><entry>0x0C</><entry>Param: angle, c1, c2 </></>
  <row><entry>PG_GROP_TEXTGRID</><entry>0x1C</><entry>Param: string, bufferw, offset</></>
  <row><entry>PG_GROP_NOP</><entry>0x03</><entry></></>
  <row><entry>PG_GROP_RESETCLIP</><entry>0x13</><entry>Reset clip to whole divnode</></>
  <row><entry>PG_GROP_SETOFFSET</><entry>0x01</><entry>this grop's rect sets offset</></>
  <row><entry>PG_GROP_SETCLIP</><entry>0x11</><entry>this grop's rect sets clipping</></>
  <row><entry>PG_GROP_SETSRC</><entry>0x21</><entry>this grop's rect sets src_*</></>
  <row><entry>PG_GROP_SETMAPPING</><entry>0x05</><entry>Param: PG_MAP_* const</></>
  <row><entry>PG_GROP_SETCOLOR</><entry>0x07</><entry>Param: pgcolor</></>
  <row><entry>PG_GROP_SETFONT</><entry>0x17</><entry>Param: font</></>
  <row><entry>PG_GROP_SETLGOP</><entry>0x27</><entry>Param: lgop</></>
  <row><entry>PG_GROP_SETANGLE</><entry>0x37</><entry>Param: angle in degrees</></>
  <row><entry>PG_GROP_VIDUPDATE</><entry>0x800</><entry>Forces a video update</></>
  </tbody>
  </tgroup>
  </table>
 </appendix>

 <appendix id="propertytypes"><title>Property Types</title>
  <para>
	(soon)
  </para>
 </appendix>

 <appendix id="requesttypes">
  <title>Request Types</title>
  <para>
	Request types are used by the client to ask the server to perform an
	action, and used by the server to determine which action to perform.
  </para>
  <para>
	Latest values may be found in
	<filename class=headerfile>picogui/network.h</filename> or on cvs in
	<filename class=headerfile>pgserver/include/picogui/network.h</filename>
  </para>
  <table frame=none pgwide=1><title>PGREQ values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PGREQ_PING</><entry>0</><entry>Simply return if server is ok</></>
  <row><entry>PGREQ_UPDATE</><entry>1</><entry>Call update()</></>
  <row><entry>PGREQ_MKWIDGET</><entry>2</><entry>Make a widget, return handle</></>
  <row><entry>PGREQ_MKBITMAP</><entry>3</><entry>Make a bitmap, return handle</></>
  <row><entry>PGREQ_MKFONT</><entry>4</><entry>Make a fontdesc, return handle</></>
  <row><entry>PGREQ_MKSTRING</><entry>5</><entry>Make a string, return handle</></>
  <row><entry>PGREQ_FREE</><entry>6</><entry>Free a handle</></>
  <row><entry>PGREQ_SET</><entry>7</><entry>Set a widget param</></>
  <row><entry>PGREQ_GET</><entry>8</><entry>Get a widget param, return it</></>
  <row><entry>PGREQ_MKTHEME</><entry>9</><entry>Load a compiled theme</></>
  <row><entry>PGREQ_IN_KEY</><entry>10</><entry>Dispatch keyboard input</></>
  <row><entry>PGREQ_IN_POINT</><entry>11</><entry>Dispatch pointing device input</></>
  <row><entry>PGREQ_WAIT</><entry>13</><entry>Wait for an event</></>
  <row><entry>PGREQ_MKFILLSTYLE</><entry>14</><entry>Load a fill style, return handle</></>
  <row><entry>PGREQ_REGISTER</><entry>15</><entry>Register a new application</></>
  <row><entry>PGREQ_MKPOPUP</><entry>16</><entry>Create a popup root widget</></>
  <row><entry>PGREQ_SIZETEXT</><entry>17</><entry>Find the size of text</></>
  <row><entry>PGREQ_BATCH</><entry>18</><entry>Execute many requests</></>
  <row><entry>PGREQ_REGOWNER</><entry>19</><entry>Get exclusive privileges</></>
  <row><entry>PGREQ_UNREGOWNER</><entry>20</><entry>Give up exclusive privileges</></>
  <row><entry>PGREQ_SETMODE</><entry>21</><entry>Set video mode/depth/rotation</></>
  <row><entry>PGREQ_GETMODE</><entry>22</><entry>Return a modeinfo struct</></>
  <row><entry>PGREQ_MKCONTEXT</><entry>23</><entry>Enter a new context</></>
  <row><entry>PGREQ_RMCONTEXT</><entry>24</><entry>Clean up and kills the context</></>
  <row><entry>PGREQ_FOCUS</><entry>25</><entry>Force focus to specified widget</></>
  <row><entry>PGREQ_GETSTRING</><entry>26</><entry>Return a RESPONSE_DATA</></>
  <row><entry>PGREQ_DUP</><entry>27</><entry>Duplicate an object</></>
  <row><entry>PGREQ_SETPAYLOAD</><entry>28</><entry>Set an object's payload</></>
  <row><entry>PGREQ_GETPAYLOAD</><entry>29</><entry>Get an object's payload</></>
  <row><entry>PGREQ_CHCONTEXT</><entry>30</><entry>Change a handle's context</></>
  <row><entry>PGREQ_WRITETO</><entry>31</><entry>Stream data to a widget</></>
  <row><entry>PGREQ_UPDATEPART</><entry>32</><entry>Update subtree defined by wgt</></>
  <row><entry>PGREQ_MKARRAY</><entry>33</><entry>Make a array, return handle</></>  
  <row><entry>PGREQ_RENDER</><entry>34</><entry>Render gropnode(s) to a bitmap</></>
  <row><entry>PGREQ_NEWBITMAP</><entry>35</><entry>Create a blank bitmap</></>
  <row><entry>PGREQ_THLOOKUP</><entry>36</><entry>Perform a theme lookup</></>
  <row><entry>PGREQ_GETINACTIVE</><entry>37</><entry>Get milliseconds of inactivity</></>
  <row><entry>PGREQ_SETINACTIVE</><entry>38</><entry>Set milliseconds of inactivity</></>
  <row><entry>PGREQ_DRIVERMSG</><entry>39</><entry>Send a message to all drivers</></>
  <row><entry>PGREQ_LOADDRIVER</><entry>40</><entry>Load input/misc (not video)</></>
  <row><entry>PGREQ_GETFSTYLE</><entry>41</><entry>Get info on a font style</></>
  <row><entry>PGREQ_FINDWIDGET</><entry>42</><entry>Get widget handle by name</></>
  <row><entry>PGREQ_CHECKEVENT</><entry>43</><entry>Return number of queued events</></>
  <row><entry>PGREQ_SIZEBITMAP</><entry>44</><entry>Find the size of a bitmap</></>
  <row><entry>PGREQ_APPMSG</><entry>45</><entry>Send PG_WE_APPMSG to any widget</></>
  <row><entry>PGREQ_CREATEWIDGET</><entry>46</><entry>Create widget</></>
  <row><entry>PGREQ_ATTACHWIDGET</><entry>47</><entry>Attach widget</></>
  <row><entry>PGREQ_FINDTHOBJ</><entry>48</><entry>Find theme object by name</></>
  <row><entry>PGREQ_TRAVERSEWGT</><entry>49</><entry>Find widgets after this one</></>
  </tbody></tgroup></table>
 </appendix>

 <appendix id="triggertypes"><title>Trigger Types</title>
  <para>
	(soon)
  </para>
 </appendix>

 <appendix id="widgetconstants"><title>Widget Types</title>
  <para>
	(soon)
  </para>
  <table pgwide=1 frame=none id="widgettypes"><title>PG_WIDGET values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PG_WIDGET_TOOLBAR</><entry>0</><entry></></>
  <row><entry>PG_WIDGET_LABEL</><entry>1</><entry></></>
  <row><entry>PG_WIDGET_SCROLL</><entry>2</><entry></></>
  <row><entry>PG_WIDGET_INDICATOR</><entry>3</><entry></></>
  <row><entry>PG_WIDGET_BITMAP</><entry>4</><entry></></>
  <row><entry>PG_WIDGET_BUTTON</><entry>5</><entry></></>
  <row><entry>PG_WIDGET_PANEL</><entry>6</><entry>Can't be used to create a new widget with PGREQ_MKWIDGET but can be returned after a PGREQ_REGISTERAPP</></>
  <row><entry>PG_WIDGET_POPUP</><entry>7</><entry>Can't be used to create a new widget with PGREQ_MKWIDGET, use PGREQ_MKPOPUP instead.</></>
  <row><entry>PG_WIDGET_BOX</><entry>8</><entry></></>
  <row><entry>PG_WIDGET_FIELD</><entry>9</><entry></></>
  <row><entry>PG_WIDGET_BACKGROUND</><entry>10</><entry>pgserver internal use only!</></>
  <row><entry>PG_WIDGET_MENUITEM</><entry>11</><entry>A variation on button</></>
  <row><entry>PG_WIDGET_TERMINAL</><entry>12</><entry>A full terminal emulator</></>
  <row><entry>PG_WIDGET_CANVAS</><entry>13</><entry></></>
  <row><entry>PG_WIDGET_CHECKBOX</><entry>14</><entry>Another variation of button</></>
  <row><entry>PG_WIDGET_FLATBUTTON</><entry>15</><entry>Yet another customized button</></>
  <row><entry>PG_WIDGET_LISTITEM</><entry>16</><entry>Still yet another...</></>
  <row><entry>PG_WIDGET_SUBMENUITEM</><entry>17</><entry>Menuitem with a submenu arrow</></>
  <row><entry>PG_WIDGET_RADIOBUTTON</><entry>18</><entry>Like a check box, but exclusive</></>
  <row><entry>PG_WIDGET_TEXTBOX</><entry>19</><entry>Client-side text layout</></>
  <row><entry>PG_WIDGET_PANELBAR</><entry>20</><entry>Draggable bar and container</></>
  </tbody>
  </tgroup>
  </table>
  <para>
  </para>
  <table frame=none pgwide=1 id="derivetypes"><title>PG_DERIVE values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PG_DERIVE_AFTER</><entry>1</><entry></></>
  <row><entry>PG_DERIVE_INSIDE</><entry>2</><entry></></>
  <row><entry>PG_DERIVE_BEFORE</><entry>3</><entry></></>
  </tbody>
  </tgroup>
  </table>
 </appendix>

 <appendix id="fontconstants"><title>Font Constants</title>
  <sect1 id="fontstyles"><title>Font Styles</title>
  <para>
	These font style constants can be used as the property flags parameter
	of a PGREQ_FINDFONT and PGREQ_MKFONT request
  </para>
  <table pgwide=1 frame=none><title>PG_FSTYLE values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PG_FSTYLE_FIXED</><entry>(1&lt;&lt;0)</><entry>Fixed width</></>
  <row><entry>PG_FSTYLE_DEFAULT</><entry>(1&lt;&lt;1)</><entry>The default font in its category, fixed or proportional.</></>
  <row><entry>PG_FSTYLE_SYMBOL</><entry>(1&lt;&lt;2)</><entry>Font contains nonstandard chars and will not be chosen unless specifically requested</></>
  <row><entry>PG_FSTYLE_SUBSET</><entry>(1&lt;&lt;3)</><entry>Font does not contain all the ASCII chars before 127, and shouldn't be used unless requested</></>
  <row><entry>PG_FSTYLE_EXTENDED</><entry>(1&lt;&lt;4)</><entry>(deprecated) Contains international characters above 127 </></>
  <row><entry>PG_FSTYLE_IBMEXTEND</><entry>(1&lt;&lt;5)</><entry>(deprecated) Has IBM-PC extended characters</></>
  <row><entry>PG_FSTYLE_DOUBLESPACE</><entry>(1&lt;&lt;7)</><entry>Add extra space between lines</></>
  <row><entry>PG_FSTYLE_BOLD</><entry>(1&lt;&lt;8)</><entry>Use or simulate a bold version of the font</></>
  <row><entry>PG_FSTYLE_ITALIC</><entry>(1&lt;&lt;9)</><entry>Use or simulate an italic version of the font</></>
  <row><entry>PG_FSTYLE_UNDERLINE</><entry>(1&lt;&lt;10)</><entry>Underlined text</></>
  <row><entry>PG_FSTYLE_STRIKEOUT</><entry>(1&lt;&lt;11)</><entry>Strikeout, a line through the middle of the text</></>
  <row><entry>PG_FSTYLE_GRAYLINE</><entry>(1&lt;&lt;12)</><entry>deprecated</></>
  <row><entry>PG_FSTYLE_FLUSH</><entry>(1&lt;&lt;14)</><entry>Disable the margin that PicoGUI puts around text</></>
  <row><entry>PG_FSTYLE_DOUBLEWIDTH</><entry>(1&lt;&lt;15)</><entry>Add extra space between characters</></>
  <row><entry>PG_FSTYLE_ITALIC2</><entry>(1&lt;&lt;16)</><entry>Twice the slant of the default italic</></>
  <row><entry>PG_FSTYLE_ENCODING_ISOLATIN1</><entry>(1&lt;&lt;4)</><entry>ISO Latin-1 encoding</></>
  <row><entry>PG_FSTYLE_ENCODING_IBM</><entry>(1&lt;&lt;5)</><entry>IBM-PC extended characters</></>
  <row><entry>PG_FSTYLE_ENCODING_UNICODE</><entry>(1&lt;&lt;17)</><entry>Unicode encoding</></>
  </tbody>
  </tgroup>
  </table>
  </sect1>
  <sect1 id="fontreps"><title>Font Representations</title>
  <para>
	These flags can be returned in a response to a PGREQ_GETFSTYLE,
	indicating supported methods of graphically representing a font.
  </para>
  <para>
	Currently this can only indicate whether a font has built-in bold,
	italic, or bolditalic bitmaps, but in the future could be used to
	indicate whether a style is bitmapped or scalable.
  </para>
  <table pgwide=1 frame=none><title>PG_FR values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PG_FR_BITMAP_NORMAL</><entry>(1&lt;&lt;0)</><entry>Normal bitmapped font</></>
  <row><entry>PG_FR_BITMAP_BOLD</><entry>(1&lt;&lt;1)</><entry>Bitmapped font with bold</></>
  <row><entry>PG_FR_BITMAP_ITALIC</><entry>(1&lt;&lt;2)</><entry>Bitmapped font with italic</></>
  <row><entry>PG_FR_BITMAP_BOLDITALIC</><entry>(1&lt;&lt;3)</><entry>Bitmapped font with bold and italic</></>
  <row><entry>PG_FR_SCALABLE</><entry>(1&lt;&lt;4)</><entry>Wishful thinking :)</></>
  </tbody>
  </tgroup>
  </table>
  </sect1>
 </appendix>

 <appendix id="keyboardtypes"><title>Keyboard Constants</title>
  <table pgwide=1 frame=none id="pgkeys"><title>PGKEY values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PGKEY_BACKSPACE</><entry>8</><entry></></>
  <row><entry>PGKEY_TAB</><entry>9</><entry></></>
  <row><entry>PGKEY_CLEAR</><entry>12</><entry></></>
  <row><entry>PGKEY_RETURN</><entry>13</><entry></></>
  <row><entry>PGKEY_PAUSE</><entry>19</><entry></></>
  <row><entry>PGKEY_ESCAPE</><entry>27</><entry></></>
  <row><entry>PGKEY_SPACE</><entry>32</><entry></></>
  <row><entry>PGKEY_EXCLAIM</><entry>33</><entry></></>
  <row><entry>PGKEY_QUOTEDBL</><entry>34</><entry></></>
  <row><entry>PGKEY_HASH</><entry>35</><entry></></>
  <row><entry>PGKEY_DOLLAR</><entry>36</><entry></></>
  <row><entry>PGKEY_PERCENT</><entry>37</><entry></></>
  <row><entry>PGKEY_AMPERSAND</><entry>38</><entry></></>
  <row><entry>PGKEY_QUOTE</><entry>39</><entry></></>
  <row><entry>PGKEY_LEFTPAREN</><entry>40</><entry></></>
  <row><entry>PGKEY_RIGHTPAREN</><entry>41</><entry></></>
  <row><entry>PGKEY_ASTERISK</><entry>42</><entry></></>
  <row><entry>PGKEY_PLUS</><entry>43</><entry></></>
  <row><entry>PGKEY_COMMA</><entry>44</><entry></></>
  <row><entry>PGKEY_MINUS</><entry>45</><entry></></>
  <row><entry>PGKEY_PERIOD</><entry>46</><entry></></>
  <row><entry>PGKEY_SLASH</><entry>47</><entry></></>
  <row><entry>PGKEY_0</><entry>48</><entry></></>
  <row><entry>PGKEY_1</><entry>49</><entry></></>
  <row><entry>PGKEY_2</><entry>50</><entry></></>
  <row><entry>PGKEY_3</><entry>51</><entry></></>
  <row><entry>PGKEY_4</><entry>52</><entry></></>
  <row><entry>PGKEY_5</><entry>53</><entry></></>
  <row><entry>PGKEY_6</><entry>54</><entry></></>
  <row><entry>PGKEY_7</><entry>55</><entry></></>
  <row><entry>PGKEY_8</><entry>56</><entry></></>
  <row><entry>PGKEY_9</><entry>57</><entry></></>
  <row><entry>PGKEY_COLON</><entry>58</><entry></></>
  <row><entry>PGKEY_SEMICOLON</><entry>59</><entry></></>
  <row><entry>PGKEY_LESS</><entry>60</><entry></></>
  <row><entry>PGKEY_EQUALS</><entry>61</><entry></></>
  <row><entry>PGKEY_GREATER</><entry>62</><entry></></>
  <row><entry>PGKEY_QUESTION</><entry>63</><entry></></>
  <row><entry>PGKEY_AT</><entry>64</><entry></></>
  <row><entry>PGKEY_LEFTBRACKET</><entry>91</><entry></></>
  <row><entry>PGKEY_BACKSLASH</><entry>92</><entry></></>
  <row><entry>PGKEY_RIGHTBRACKET</><entry>93</><entry></></>
  <row><entry>PGKEY_CARET</><entry>94</><entry></></>
  <row><entry>PGKEY_UNDERSCORE</><entry>95</><entry></></>
  <row><entry>PGKEY_BACKQUOTE</><entry>96</><entry></></>
  <row><entry>PGKEY_a</><entry>97</><entry></></>
  <row><entry>PGKEY_b</><entry>98</><entry></></>
  <row><entry>PGKEY_c</><entry>99</><entry></></>
  <row><entry>PGKEY_d</><entry>100</><entry></></>
  <row><entry>PGKEY_e</><entry>101</><entry></></>
  <row><entry>PGKEY_f</><entry>102</><entry></></>
  <row><entry>PGKEY_g</><entry>103</><entry></></>
  <row><entry>PGKEY_h</><entry>104</><entry></></>
  <row><entry>PGKEY_i</><entry>105</><entry></></>
  <row><entry>PGKEY_j</><entry>106</><entry></></>
  <row><entry>PGKEY_k</><entry>107</><entry></></>
  <row><entry>PGKEY_l</><entry>108</><entry></></>
  <row><entry>PGKEY_m</><entry>109</><entry></></>
  <row><entry>PGKEY_n</><entry>110</><entry></></>
  <row><entry>PGKEY_o</><entry>111</><entry></></>
  <row><entry>PGKEY_p</><entry>112</><entry></></>
  <row><entry>PGKEY_q</><entry>113</><entry></></>
  <row><entry>PGKEY_r</><entry>114</><entry></></>
  <row><entry>PGKEY_s</><entry>115</><entry></></>
  <row><entry>PGKEY_t</><entry>116</><entry></></>
  <row><entry>PGKEY_u</><entry>117</><entry></></>
  <row><entry>PGKEY_v</><entry>118</><entry></></>
  <row><entry>PGKEY_w</><entry>119</><entry></></>
  <row><entry>PGKEY_x</><entry>120</><entry></></>
  <row><entry>PGKEY_y</><entry>121</><entry></></>
  <row><entry>PGKEY_z</><entry>122</><entry></></>
  <row><entry>PGKEY_LEFTBRACE</><entry>123</><entry></></>
  <row><entry>PGKEY_PIPE</><entry>124</><entry></></>
  <row><entry>PGKEY_RIGHTBRACE</><entry>125</><entry></></>
  <row><entry>PGKEY_TILDE</><entry>126</><entry></></>
  <row><entry>PGKEY_DELETE</><entry>127</><entry></></>
  <row><entry>PGKEY_WORLD_0</><entry>160</><entry>0xA0</></>
  <row><entry>PGKEY_WORLD_1</><entry>161</><entry></></>
  <row><entry>PGKEY_WORLD_2</><entry>162</><entry></></>
  <row><entry>PGKEY_WORLD_3</><entry>163</><entry></></>
  <row><entry>PGKEY_WORLD_4</><entry>164</><entry></></>
  <row><entry>PGKEY_WORLD_5</><entry>165</><entry></></>
  <row><entry>PGKEY_WORLD_6</><entry>166</><entry></></>
  <row><entry>PGKEY_WORLD_7</><entry>167</><entry></></>
  <row><entry>PGKEY_WORLD_8</><entry>168</><entry></></>
  <row><entry>PGKEY_WORLD_9</><entry>169</><entry></></>
  <row><entry>PGKEY_WORLD_10</><entry>170</><entry></></>
  <row><entry>PGKEY_WORLD_11</><entry>171</><entry></></>
  <row><entry>PGKEY_WORLD_12</><entry>172</><entry></></>
  <row><entry>PGKEY_WORLD_13</><entry>173</><entry></></>
  <row><entry>PGKEY_WORLD_14</><entry>174</><entry></></>
  <row><entry>PGKEY_WORLD_15</><entry>175</><entry></></>
  <row><entry>PGKEY_WORLD_16</><entry>176</><entry></></>
  <row><entry>PGKEY_WORLD_17</><entry>177</><entry></></>
  <row><entry>PGKEY_WORLD_18</><entry>178</><entry></></>
  <row><entry>PGKEY_WORLD_19</><entry>179</><entry></></>
  <row><entry>PGKEY_WORLD_20</><entry>180</><entry></></>
  <row><entry>PGKEY_WORLD_21</><entry>181</><entry></></>
  <row><entry>PGKEY_WORLD_22</><entry>182</><entry></></>
  <row><entry>PGKEY_WORLD_23</><entry>183</><entry></></>
  <row><entry>PGKEY_WORLD_24</><entry>184</><entry></></>
  <row><entry>PGKEY_WORLD_25</><entry>185</><entry></></>
  <row><entry>PGKEY_WORLD_26</><entry>186</><entry></></>
  <row><entry>PGKEY_WORLD_27</><entry>187</><entry></></>
  <row><entry>PGKEY_WORLD_28</><entry>188</><entry></></>
  <row><entry>PGKEY_WORLD_29</><entry>189</><entry></></>
  <row><entry>PGKEY_WORLD_30</><entry>190</><entry></></>
  <row><entry>PGKEY_WORLD_31</><entry>191</><entry></></>
  <row><entry>PGKEY_WORLD_32</><entry>192</><entry></></>
  <row><entry>PGKEY_WORLD_33</><entry>193</><entry></></>
  <row><entry>PGKEY_WORLD_34</><entry>194</><entry></></>
  <row><entry>PGKEY_WORLD_35</><entry>195</><entry></></>
  <row><entry>PGKEY_WORLD_36</><entry>196</><entry></></>
  <row><entry>PGKEY_WORLD_37</><entry>197</><entry></></>
  <row><entry>PGKEY_WORLD_38</><entry>198</><entry></></>
  <row><entry>PGKEY_WORLD_39</><entry>199</><entry></></>
  <row><entry>PGKEY_WORLD_40</><entry>200</><entry></></>
  <row><entry>PGKEY_WORLD_41</><entry>201</><entry></></>
  <row><entry>PGKEY_WORLD_42</><entry>202</><entry></></>
  <row><entry>PGKEY_WORLD_43</><entry>203</><entry></></>
  <row><entry>PGKEY_WORLD_44</><entry>204</><entry></></>
  <row><entry>PGKEY_WORLD_45</><entry>205</><entry></></>
  <row><entry>PGKEY_WORLD_46</><entry>206</><entry></></>
  <row><entry>PGKEY_WORLD_47</><entry>207</><entry></></>
  <row><entry>PGKEY_WORLD_48</><entry>208</><entry></></>
  <row><entry>PGKEY_WORLD_49</><entry>209</><entry></></>
  <row><entry>PGKEY_WORLD_50</><entry>210</><entry></></>
  <row><entry>PGKEY_WORLD_51</><entry>211</><entry></></>
  <row><entry>PGKEY_WORLD_52</><entry>212</><entry></></>
  <row><entry>PGKEY_WORLD_53</><entry>213</><entry></></>
  <row><entry>PGKEY_WORLD_54</><entry>214</><entry></></>
  <row><entry>PGKEY_WORLD_55</><entry>215</><entry></></>
  <row><entry>PGKEY_WORLD_56</><entry>216</><entry></></>
  <row><entry>PGKEY_WORLD_57</><entry>217</><entry></></>
  <row><entry>PGKEY_WORLD_58</><entry>218</><entry></></>
  <row><entry>PGKEY_WORLD_59</><entry>219</><entry></></>
  <row><entry>PGKEY_WORLD_60</><entry>220</><entry></></>
  <row><entry>PGKEY_WORLD_61</><entry>221</><entry></></>
  <row><entry>PGKEY_WORLD_62</><entry>222</><entry></></>
  <row><entry>PGKEY_WORLD_63</><entry>223</><entry></></>
  <row><entry>PGKEY_WORLD_64</><entry>224</><entry></></>
  <row><entry>PGKEY_WORLD_65</><entry>225</><entry></></>
  <row><entry>PGKEY_WORLD_66</><entry>226</><entry></></>
  <row><entry>PGKEY_WORLD_67</><entry>227</><entry></></>
  <row><entry>PGKEY_WORLD_68</><entry>228</><entry></></>
  <row><entry>PGKEY_WORLD_69</><entry>229</><entry></></>
  <row><entry>PGKEY_WORLD_70</><entry>230</><entry></></>
  <row><entry>PGKEY_WORLD_71</><entry>231</><entry></></>
  <row><entry>PGKEY_WORLD_72</><entry>232</><entry></></>
  <row><entry>PGKEY_WORLD_73</><entry>233</><entry></></>
  <row><entry>PGKEY_WORLD_74</><entry>234</><entry></></>
  <row><entry>PGKEY_WORLD_75</><entry>235</><entry></></>
  <row><entry>PGKEY_WORLD_76</><entry>236</><entry></></>
  <row><entry>PGKEY_WORLD_77</><entry>237</><entry></></>
  <row><entry>PGKEY_WORLD_78</><entry>238</><entry></></>
  <row><entry>PGKEY_WORLD_79</><entry>239</><entry></></>
  <row><entry>PGKEY_WORLD_80</><entry>240</><entry></></>
  <row><entry>PGKEY_WORLD_81</><entry>241</><entry></></>
  <row><entry>PGKEY_WORLD_82</><entry>242</><entry></></>
  <row><entry>PGKEY_WORLD_83</><entry>243</><entry></></>
  <row><entry>PGKEY_WORLD_84</><entry>244</><entry></></>
  <row><entry>PGKEY_WORLD_85</><entry>245</><entry></></>
  <row><entry>PGKEY_WORLD_86</><entry>246</><entry></></>
  <row><entry>PGKEY_WORLD_87</><entry>247</><entry></></>
  <row><entry>PGKEY_WORLD_88</><entry>248</><entry></></>
  <row><entry>PGKEY_WORLD_89</><entry>249</><entry></></>
  <row><entry>PGKEY_WORLD_90</><entry>250</><entry></></>
  <row><entry>PGKEY_WORLD_91</><entry>251</><entry></></>
  <row><entry>PGKEY_WORLD_92</><entry>252</><entry></></>
  <row><entry>PGKEY_WORLD_93</><entry>253</><entry></></>
  <row><entry>PGKEY_WORLD_94</><entry>254</><entry></></>
  <row><entry>PGKEY_WORLD_95</><entry>255</><entry>0xFF</></>
  <row><entry>PGKEY_KP0</><entry>256</><entry></></>
  <row><entry>PGKEY_KP1</><entry>257</><entry></></>
  <row><entry>PGKEY_KP2</><entry>258</><entry></></>
  <row><entry>PGKEY_KP3</><entry>259</><entry></></>
  <row><entry>PGKEY_KP4</><entry>260</><entry></></>
  <row><entry>PGKEY_KP5</><entry>261</><entry></></>
  <row><entry>PGKEY_KP6</><entry>262</><entry></></>
  <row><entry>PGKEY_KP7</><entry>263</><entry></></>
  <row><entry>PGKEY_KP8</><entry>264</><entry></></>
  <row><entry>PGKEY_KP9</><entry>265</><entry></></>
  <row><entry>PGKEY_KP_PERIOD</><entry>266</><entry></></>
  <row><entry>PGKEY_KP_DIVIDE</><entry>267</><entry></></>
  <row><entry>PGKEY_KP_MULTIPLY</><entry>268</><entry></></>
  <row><entry>PGKEY_KP_MINUS</><entry>269</><entry></></>
  <row><entry>PGKEY_KP_PLUS</><entry>270</><entry></></>
  <row><entry>PGKEY_KP_ENTER</><entry>271</><entry></></>
  <row><entry>PGKEY_KP_EQUALS</><entry>272</><entry></></>
  <row><entry>PGKEY_UP</><entry>273</><entry></></>
  <row><entry>PGKEY_DOWN</><entry>274</><entry></></>
  <row><entry>PGKEY_RIGHT</><entry>275</><entry></></>
  <row><entry>PGKEY_LEFT</><entry>276</><entry></></>
  <row><entry>PGKEY_INSERT</><entry>277</><entry></></>
  <row><entry>PGKEY_HOME</><entry>278</><entry></></>
  <row><entry>PGKEY_END</><entry>279</><entry></></>
  <row><entry>PGKEY_PAGEUP</><entry>280</><entry></></>
  <row><entry>PGKEY_PAGEDOWN</><entry>281</><entry></></>
  <row><entry>PGKEY_F1</><entry>282</><entry></></>
  <row><entry>PGKEY_F2</><entry>283</><entry></></>
  <row><entry>PGKEY_F3</><entry>284</><entry></></>
  <row><entry>PGKEY_F4</><entry>285</><entry></></>
  <row><entry>PGKEY_F5</><entry>286</><entry></></>
  <row><entry>PGKEY_F6</><entry>287</><entry></></>
  <row><entry>PGKEY_F7</><entry>288</><entry></></>
  <row><entry>PGKEY_F8</><entry>289</><entry></></>
  <row><entry>PGKEY_F9</><entry>290</><entry></></>
  <row><entry>PGKEY_F10</><entry>291</><entry></></>
  <row><entry>PGKEY_F11</><entry>292</><entry></></>
  <row><entry>PGKEY_F12</><entry>293</><entry></></>
  <row><entry>PGKEY_F13</><entry>294</><entry></></>
  <row><entry>PGKEY_F14</><entry>295</><entry></></>
  <row><entry>PGKEY_F15</><entry>296</><entry></></>
  <row><entry>PGKEY_NUMLOCK</><entry>300</><entry></></>
  <row><entry>PGKEY_CAPSLOCK</><entry>301</><entry></></>
  <row><entry>PGKEY_SCROLLOCK</><entry>302</><entry></></>
  <row><entry>PGKEY_RSHIFT</><entry>303</><entry></></>
  <row><entry>PGKEY_LSHIFT</><entry>304</><entry></></>
  <row><entry>PGKEY_RCTRL</><entry>305</><entry></></>
  <row><entry>PGKEY_LCTRL</><entry>306</><entry></></>
  <row><entry>PGKEY_RALT</><entry>307</><entry></></>
  <row><entry>PGKEY_LALT</><entry>308</><entry></></>
  <row><entry>PGKEY_RMETA</><entry>309</><entry></></>
  <row><entry>PGKEY_LMETA</><entry>310</><entry></></>
  <row><entry>PGKEY_LSUPER</><entry>311</><entry>Left "Windows" key</></>
  <row><entry>PGKEY_RSUPER</><entry>312</><entry>Right "Windows" key</></>
  <row><entry>PGKEY_MODE</><entry>313</><entry>"AltGr" key</></>
  <row><entry>PGKEY_HELP</><entry>315</><entry></></>
  <row><entry>PGKEY_PRINT</><entry>316</><entry></></>
  <row><entry>PGKEY_SYSREQ</><entry>317</><entry></></>
  <row><entry>PGKEY_BREAK</><entry>318</><entry></></>
  <row><entry>PGKEY_MENU</><entry>319</><entry></></>
  <row><entry>PGKEY_POWER</><entry>320</><entry>Power Macintosh powerkey</></>
  <row><entry>PGKEY_EURO</><entry>321</><entry>Some european keyboards</></>
  <row><entry>PGKEY_ALPHA</><entry>322</><entry>Selects letters on a numeric keypad (for celphones and similar devices)</></>
  </tbody>
  </tgroup>
  </table>
  <para>
  </para>
  <table pgwide=1 frame=none id="pgmod"><title>PGMOD values</title>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PGMOD_LSHIFT</><entry>0001</><entry></></>
  <row><entry>PGMOD_RSHIFT</><entry>0002</><entry></></>
  <row><entry>PGMOD_SHIFT</><entry>0003</><entry></></>
  <row><entry>PGMOD_LCTRL</><entry>0040</><entry></></>
  <row><entry>PGMOD_RCTRL</><entry>0080</><entry></></>
  <row><entry>PGMOD_CTRL</><entry>00C0</><entry></></>
  <row><entry>PGMOD_LALT</><entry>0100</><entry></></>
  <row><entry>PGMOD_RALT</><entry>0200</><entry></></>
  <row><entry>PGMOD_ALT</><entry>0300</><entry></></>
  <row><entry>PGMOD_LMETA</><entry>0400</><entry></></>
  <row><entry>PGMOD_RMETA</><entry>0800</><entry></></>
  <row><entry>PGMOD_META</><entry>0C00</><entry></></>
  <row><entry>PGMOD_NUM</><entry>1000</><entry></></>
  <row><entry>PGMOD_CAPS</><entry>2000</><entry></></>
  <row><entry>PGMOD_MODE</><entry>4000</><entry></></>
  </tbody>
  </table>
 </appendix>
 
 <appendix>
  <title>Theme Constants</title>
  <sect1 id="pgthotypes"><title>Theme Object Types</>
  <table pgwide=1 frame=none><title>PGTH_O values</>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PGTH_O_DEFAULT</><entry>0</><entry>Every theme object inherits this</></>
  <row><entry>PGTH_O_BASE_INTERACTIVE</><entry>1</><entry>Base for interactive widgets</></>
  <row><entry>PGTH_O_BASE_CONTAINER</><entry>2</><entry>Base for containers like toolbars</></>
  <row><entry>PGTH_O_BUTTON</><entry>3</><entry>The button widget</></>
  <row><entry>PGTH_O_BUTTON_HILIGHT</><entry>4</><entry>Button, hilighted when mouse is over</></>
  <row><entry>PGTH_O_BUTTON_ON</><entry>5</><entry>Button, mouse is pressed</></>
  <row><entry>PGTH_O_TOOLBAR</><entry>6</><entry>The toolbar widget</></>
  <row><entry>PGTH_O_SCROLL</><entry>7</><entry>The scrollbar widget</></>
  <row><entry>PGTH_O_SCROLL_HILIGHT</><entry>8</><entry>Scroll, when mouse is over it</></>
  <row><entry>PGTH_O_INDICATOR</><entry>9</><entry>The indicator widget</></>
  <row><entry>PGTH_O_PANEL</><entry>10</><entry>The background portion of a panel</></>
  <row><entry>PGTH_O_PANELBAR</><entry>11</><entry>The draggable titlebar of a panel</></>
  <row><entry>PGTH_O_POPUP</><entry>12</><entry>Popup window</></>
  <row><entry>PGTH_O_BACKGROUND</><entry>13</><entry>Background widget bitmap</></>
  <row><entry>PGTH_O_BASE_DISPLAY</><entry>14</><entry>Base for widgets that mostly display stuff</></>
  <row><entry>PGTH_O_BASE_TLCONTAINER</><entry>15</><entry>Top-level containers like popups, panels</></>
  <row><entry>PGTH_O_THEMEINFO</><entry>16</><entry>Information about the theme that should be loaded into memory, like the name</></>
  <row><entry>PGTH_O_LABEL</><entry>17</><entry>The label widget</></>
  <row><entry>PGTH_O_FIELD</><entry>18</><entry>The field widget</></>
  <row><entry>PGTH_O_BITMAP</><entry>19</><entry>The bitmap widget</></>
  <row><entry>PGTH_O_SCROLL_ON</><entry>20</><entry>Scroll, when mouse is down</></>
  <row><entry>PGTH_O_LABEL_SCROLL</><entry>21</><entry>A label, when bound to a scrollbar</></>
  <row><entry>PGTH_O_PANELBAR_HILIGHT</><entry>22</><entry>A panelbar, when mouse is inside it</></>
  <row><entry>PGTH_O_PANELBAR_ON</><entry>23</><entry>A panelbar, when mouse is down</></>
  <row><entry>PGTH_O_BOX</><entry>24</><entry>The box widget</></>
  <row><entry>PGTH_O_LABEL_DLGTITLE</><entry>25</><entry>A label, used for a dialog box title</></>
  <row><entry>PGTH_O_LABEL_DLGTEXT</><entry>26</><entry>A label, used for the body of a dialog</></>
  <row><entry>PGTH_O_CLOSEBTN</><entry>27</><entry>A panelbar close button</></>
  <row><entry>PGTH_O_CLOSEBTN_ON</><entry>28</><entry>A panelbar close button, mouse down</></>
  <row><entry>PGTH_O_CLOSEBTN_HILIGHT</><entry>29</><entry>A panelbar close button, mouse over</></>
  <row><entry>PGTH_O_BASE_PANELBTN</><entry>30</><entry>Base for a panelbar button</></>
  <row><entry>PGTH_O_ROTATEBTN</><entry>31</><entry>A panelbar rotate button</></>
  <row><entry>PGTH_O_ROTATEBTN_ON</><entry>32</><entry>A panelbar rotate button, mouse down</></>
  <row><entry>PGTH_O_ROTATEBTN_HILIGHT</><entry>33</><entry>A panelbar rotate button, mouse over</></>
  <row><entry>PGTH_O_ZOOMBTN</><entry>34</><entry>A panelbar zoom button</></>
  <row><entry>PGTH_O_ZOOMBTN_ON</><entry>35</><entry>A panelbar zoom button, mouse down</></>
  <row><entry>PGTH_O_ZOOMBTN_HILIGHT</><entry>36</><entry>A panelbar zoom button, mouse over</></>
  <row><entry>PGTH_O_POPUP_MENU</><entry>37</><entry>A popup menu</></>
  <row><entry>PGTH_O_POPUP_MESSAGEDLG</><entry>38</><entry>A message dialog</></>
  <row><entry>PGTH_O_MENUITEM</><entry>39</><entry>Item in a popup menu (customized button)</></>
  <row><entry>PGTH_O_MENUITEM_HILIGHT</><entry>40</><entry>menuitem with the mouse over it</></>
  <row><entry>PGTH_O_CHECKBOX</><entry>41</><entry>Check box (customized button)</></>
  <row><entry>PGTH_O_CHECKBOX_HILIGHT</><entry>42</><entry>checkbox with mouse over it</></>
  <row><entry>PGTH_O_CHECKBOX_ON</><entry>43</><entry>checkbox when on</></>
  <row><entry>PGTH_O_FLATBUTTON</><entry>44</><entry>Flat button (customized button)</></>
  <row><entry>PGTH_O_FLATBUTTON_HILIGHT</><entry>45</><entry>flatbutton with mouse over it</></>
  <row><entry>PGTH_O_FLATBUTTON_ON</><entry>46</><entry>flatbutton with mouse down</></>
  <row><entry>PGTH_O_LISTITEM</><entry>47</><entry>Listitem (customized button)</></>
  <row><entry>PGTH_O_LISTITEM_HILIGHT</><entry>48</><entry>Listitem with mouse over it</></>
  <row><entry>PGTH_O_LISTITEM_ON</><entry>49</><entry>Selected listitem</></>
  <row><entry>PGTH_O_CHECKBOX_ON_NOHILIGHT</><entry>50</><entry>checkbox when on but not hilighted</></>
  <row><entry>PGTH_O_SUBMENUITEM</><entry>51</><entry>Submenuitem</></>
  <row><entry>PGTH_O_SUBMENUITEM_HILIGHT</><entry>52</><entry>Hilighted submenuitem</></>
  <row><entry>PGTH_O_RADIOBUTTON</><entry>53</><entry>Radio button (cust. button)</></>
  <row><entry>PGTH_O_RADIOBUTTON_HILIGHT</><entry>54</><entry>Radio button (cust. button)</></>
  <row><entry>PGTH_O_RADIOBUTTON_ON</><entry>55</><entry>Radio button (cust. button)</></>
  <row><entry>PGTH_O_RADIOBUTTON_ON_NOHILIGHT</><entry>56</><entry>Radio button (cust. button)</></>
  <row><entry>PGTH_O_TEXTBOX</><entry>57</><entry>Textbox widget</></>
  <row><entry>PGTH_O_TERMINAL</><entry>58</><entry>Terminal widget</></>
  <row><entry>PGTH_O_LIST</><entry>59</><entry>RidgeRun's list box widget</></>
  <row><entry>PGTH_O_MENUBUTTON</><entry>60</><entry>DSPLinux Application Menu</></>
  <row><entry>PGTH_O_MENUBUTTON_ON</><entry>61</><entry>DSPLinux Application Menu</></>
  <row><entry>PGTH_O_MENUBUTTON_HILIGHT</><entry>62</><entry>DSPLinux Application Menu</></>
  <row><entry>PGTH_O_LABEL_HILIGHT</><entry>63</><entry>Label hilight or select - See PG_WP_HILIGHTED</></>
  <row><entry>PGTH_O_BOX_HILIGHT</><entry>64</><entry>Box hilight or select - See PG_WP_HILIGHTED</></>
  <row><entry>PGTH_O_INDICATOR_H</><entry>65</><entry>Horizontal indicator</></>
  <row><entry>PGTH_O_INDICATOR_V</><entry>66</><entry>Vertical indicator</></>
  </tbody>
  </tgroup>
  </table>
  </sect1>
  <sect1 id="pgthptypes"><title>Theme Property Types</>
  <table pgwide=1 frame=none><title>PGTH_P values</>
  <tgroup cols=3 align=left>
  <colspec colwidth="45*">
  <colspec colwidth="10*">
  <colspec colwidth="45*">
  <tbody>
  <row><entry>PGTH_P_BGCOLOR</><entry>1</><entry>Default background color</></>
  <row><entry>PGTH_P_FGCOLOR</><entry>2</><entry>Default foreground color</></>
  <row><entry>PGTH_P_BGFILL</><entry>3</><entry>Background fillstyle</></>
  <row><entry>PGTH_P_OVERLAY</><entry>4</><entry>Fillstyle for scroll thumbs, the filled portion of an indicator</></>
  <row><entry>PGTH_P_FONT</><entry>5</><entry>A widget's main font</></>
  <row><entry>PGTH_P_NAME</><entry>6</><entry>Name of the theme object, themes can be searched by this</></>
  <row><entry>PGTH_P_WIDTH</><entry>7</><entry>Reccomended width</></>
  <row><entry>PGTH_P_HEIGHT</><entry>8</><entry>Reccomended height</></>
  <row><entry>PGTH_P_MARGIN</><entry>9</><entry>The border in some objects</></>
  <row><entry>PGTH_P_HILIGHTCOLOR</><entry>10</><entry>Color for hilighting an object</></>
  <row><entry>PGTH_P_SHADOWCOLOR</><entry>11</><entry>Color for shading an object</></>
  <row><entry>PGTH_P_OFFSET</><entry>12</><entry>An amount to displace something by</></>
  <row><entry>PGTH_P_ALIGN</><entry>13</><entry>How to position an object's contents</></>
  <row><entry>PGTH_P_BITMAPSIDE</><entry>14</><entry>Bitmap side relative to text (button)</></>
  <row><entry>PGTH_P_BITMAPMARGIN</><entry>15</><entry>Spacing between bitmap and text</></>
  <row><entry>PGTH_P_BITMAP1</><entry>16</><entry>Generic bitmap property for theme use</></>
  <row><entry>PGTH_P_BITMAP2</><entry>17</><entry>Generic bitmap property for theme use</></>
  <row><entry>PGTH_P_BITMAP3</><entry>18</><entry>Generic bitmap property for theme use</></>
  <row><entry>PGTH_P_BITMAP4</><entry>19</><entry>Generic bitmap property for theme use</></>
  <row><entry>PGTH_P_SPACING</><entry>20</><entry>Distance between similar widgets</></>
  <row><entry>PGTH_P_TEXT</><entry>21</><entry>Text caption for something like a button</></>
  <row><entry>PGTH_P_SIDE</><entry>22</><entry>Side for a widget or subwidget</></>
  <row><entry>PGTH_P_BACKDROP</><entry>23</><entry>Fillstyle on the screen behind a popup</></>
  <row><entry>PGTH_P_WIDGETBITMAP</><entry>24</><entry>Bitmap for something like a button</></>
  <row><entry>PGTH_P_WIDGETBITMASK</><entry>25</><entry>Bitmask for something like a button</></>
  <row><entry>PGTH_P_CURSORBITMAP</><entry>26</><entry>Bitmap for the (mouse) pointer</></>
  <row><entry>PGTH_P_CURSORBITMASK</><entry>27</><entry>Bitmask for the (mouse) pointer</></>
  <row><entry>PGTH_P_HIDEHOTKEYS</><entry>28</><entry>Set to a PG_HHK_* constant</></>
  <row><entry>PGTH_P_ATTR_DEFAULT</><entry>29</><entry>Default attribute for the terminal</></>
  <row><entry>PGTH_P_ATTR_CURSOR</><entry>30</><entry>Default attribute for the terminal</></>
  <row><entry>PGTH_P_TEXTCOLORS</><entry>31</><entry>Text color pallete for the terminal</></>
  <row><entry>PGTH_P_TIME_ON</><entry>32</><entry>Milliseconds on for flashing cursor</></>
  <row><entry>PGTH_P_TIME_OFF</><entry>33</><entry>Milliseconds off for flashing cursor</></>
  <row><entry>PGTH_P_TIME_DELAY</><entry>34</><entry>Milliseconds to wait before flashing</></>
  <row><entry>PGTH_P_PARENT</><entry>35</><entry>Overrides the default theme inheritance</></>
  <row><entry>PGTH_P_STRING_OK</><entry>501</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_OK</><entry>501</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_CANCEL</><entry>502</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_YES</><entry>503</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_NO</><entry>504</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_SEGFAULT</><entry>505</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_MATHERR</><entry>506</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_PGUIERR</><entry>507</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_PGUIWARN</><entry>508</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_PGUIERRDLG</><entry>509</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_STRING_PGUICOMPAT</><entry>510</><entry>String property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_OK</><entry>1000</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_OK_MASK</><entry>1001</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_CANCEL</><entry>1002</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_CANCEL_MASK</><entry>1003</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_YES</><entry>1004</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_YES_MASK</><entry>1005</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_NO</><entry>1006</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_NO_MASK</><entry>1007</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_ERROR</><entry>1008</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_ERROR_MASK</><entry>1009</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_MESSAGE</><entry>1010</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_MESSAGE_MASK</><entry>1011</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_QUESTION</><entry>1012</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_QUESTION_MASK</><entry>1013</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_WARNING</><entry>1014</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_ICON_WARNING_MASK</><entry>1015</><entry>Icon property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_OK</><entry>1501</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_CANCEL</><entry>1502</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_YES</><entry>1503</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_NO</><entry>1504</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_UP</><entry>1505</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_DOWN</><entry>1506</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_LEFT</><entry>1507</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_RIGHT</><entry>1508</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_ACTIVATE</><entry>1509</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_HOTKEY_NEXT</><entry>1510</><entry>Hotkey property (usually in PGTH_O_DEFAULT)</></>
  <row><entry>PGTH_P_USER</><entry>10000</><entry>Application-defined theme property start range</></>
  <row><entry>PGTH_P_THEMEAUTO</><entry>20000</><entry>Automatically allocated properties used only by the theme start range</></>
  </tbody>
  </tgroup>
  </table>
  </sect1>
 </appendix>

 <appendix>
  <title>Driver Messages Constants</title>
  <sect1 id="pgdmtypes"><title>Generic Driver Message Types</>
   <table pgwide=1 frame=none><title>PGDM values</>
   <tgroup cols=3 align=left>
   <colspec colwidth="45*">
   <colspec colwidth="10*">
   <colspec colwidth="45*">
   <tbody>
   <row><entry>PGDM_CURSORVISIBLE</><entry>1</><entry>Turn the cursor on/off</></>
   <row><entry>PGDM_BACKLIGHT</><entry>2</><entry>Turn the backlight on/off</></>
   <row><entry>PGDM_SOUNDFX</><entry>3</><entry>Parameter is a PG_SND_* constant</></>
   <row><entry>PGDM_POWER</><entry>4</><entry>Enter the power mode, PG_POWER_*</></>
   <row><entry>PGDM_SDC_CHAR</><entry>5</><entry>Send a character to the secondary display channel</></>
   <row><entry>PGDM_BRIGHTNESS</><entry>6</><entry>Set display brightness, 0x00-0xFF</></>
   <row><entry>PGDM_CONTRAST</><entry>7</><entry>Set display contrast, 0x00-0xFF</></>
   <row><entry>PGDM_INPUT_RAW</><entry>8</><entry>Send PG_NWE_PNTR_RAW from the specified widget</></>
   <row><entry>PGDM_INPUT_SETCAL</><entry>9</><entry>Param is a handle to a new calibration string</></>
   <row><entry>PGDM_CURSORBLKEN</><entry>10</><entry>Cursor blanking on/off</></>
   <row><entry>PGDM_INPUT_CALEN</><entry>11</><entry>Turn calibration mode on/off</></>
   <row><entry>PGDM_CURSORWARP</><entry>12</><entry>Internal message, notify drivers of a cursor warp</></>
   <row><entry>PGDM_SIGNAL</><entry>13</><entry>Internal message, sends SIGUSR1/2 to drivers (param is signal)</></>
   <row><entry>PGDM_READY</><entry>14</><entry>Notify the drivers that the server is completely up</></>
   </tbody>
   </tgroup>
   </table>
  </sect1>
 </appendix>
</book>
