/* $Id$
 *
 * picogui/network.h - Structures and constants needed by the PicoGUI client
 *                     library, but not by the application
 *
 * PicoGUI small and efficient client/server GUI
 * Copyright (C) 2000-2003 Micah Dowty <micahjd@users.sourceforge.net>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  
 * 
 * Contributors:
 * 
 * 
 * 
 */

#ifndef _H_PG_NETWORK
#define _H_PG_NETWORK

/* This #ifndef is necessary since some systems already have this defined in another file. */
/* I don't know where cygwin gets the right declarations from, but if we just omit this
 * include, for some reason, it works -- lalo */
#if !defined(ntohl) && !defined(__CYGWIN__)
//#include <netinet/in.h>
#endif

#define PG_REQUEST_PORT    30450
#define PG_PROTOCOL_VER    21     /* Increment this whenever changes are made */
#define PG_REQUEST_MAGIC   0x31415926

#include <picogui/types.h>

/******* Packet structures */

/* Request, the only packet ever sent from client to server */
struct pgrequest {
  u32 id;  /* Just to make sure requests match up with responses */
  u32 size; /* The request is followed by size bytes of data */
  u16 type;
  u16 dummy; /* Padding */
};  

/* various response packets, sent to the client after the 
   server processes a request packet */
 
#define PG_MAX_RESPONSE_SZ 12  /* in bytes */

#define PG_RESPONSE_ERR 1
struct pgresponse_err {
  u16 type;    /* RESPONSE_ERR - error code */
  u16 errt;
  u16 msglen;  /* Length of following message */
  u16 dummy; /* Padding */
  u32 id;
};

#define PG_RESPONSE_RET 2
struct pgresponse_ret {
  u16 type;    /* RESPONSE_RET - return value */
  u16 dummy; /* Padding */
  u32 id;
  u32 data;
};

#define PG_RESPONSE_EVENT 3
struct pgresponse_event {
  u16 type;    /* RESPONSE_EVENT */
  u16 event;
  u32 from;
  u32 param;
  /* If we're using PG_EVENTCODING_DATA */
};

#define PG_RESPONSE_DATA 4
struct pgresponse_data {
  u16 type;    /* RESPONSE_DATA */
  u16 dummy; /* Padding */
  u32 id;
  u32 size;
  /* 'size' bytes of data follow */
};

/* This is sent to the client after establishing a connection */
struct pghello {
  u32 magic;
  u16 protover;       /* Protocol version, defined above               */
  u16 serverversion;  /* Implementation version, see picogui/version.h */
};

/* A client-side representation of triggers, used for client-side input filters
 * and event handling. The whole structure can be viewed as a 64-byte packet of
 * 16 u32 variables, so that more trigger types can be added without disrupting
 * the client libraries or the protocol.
 */
union pg_client_trigger {
  u32 array[16];
  struct {
    u32 infilter_from;           /* Handle of input filter this is generated by */
    u32 type;                    /* PG_TRIGGER_* constant                       */
    union {                      /* Type-dependent data (must be 14 or less vars each) */
      
      struct {
	u32 x,y,btn,pressure;    /* Current status */
	u32 chbtn;               /* Changed buttons */
	u32 cursor_handle;
	u32 is_logical;          /* Nonzero if events are in logical coordinates */
	u32 ts_calibration;      /* Handle of a calibration string for the touchscreen */
	u32 divtree;             /* The divtree to dispatch the event to, 0 for top */
      } mouse;

      struct {
	u32 key;                 /* PGKEY_* constant */
	u32 mods;                /* PGMOD_* constant */
	u32 flags;               /* PG_KF_* constants */
	u32 consume;             /* Consume event during widget propagation */
	u32 divtree;             /* The divtree to dispatch the event to, 0 for top */
      } kbd;

      struct {
	u32 position[3];         /* Position axes normalized between 0 and 0x7FFFFFFF */
	u32 orientation[3];      /* Position axes normalized between 0 and 0x7FFFFFFF */
	u32 bodyPart;          /* A PG_BODYPART_* constant indicating what this motion data is for */
      } motion;

    } u;
  } content;
};

/******* Request handlers */

/* Constants for request handlers                                 args  */
#define PGREQ_PING         0   /* Simply returns if server is ok |   none  */
#define PGREQ_UPDATE       1   /* Call update()                  |   none  */
#define PGREQ_MKWIDGET     2   /* Makes a widget, returns handle |  struct */
#define PGREQ_MKBITMAP     3   /* Makes a bitmap, returns handle |  data   */
#define PGREQ_MKFONT       4   /* Makes a fontdesc, ret's handle |  struct */
#define PGREQ_MKSTRING     5   /* Makes a string, returns handle |  chars  */
#define PGREQ_FREE         6   /* Frees a handle                 |  handle */
#define PGREQ_SET          7   /* Set a widget param             |  struct */
#define PGREQ_GET          8   /* Get a widget param, return it  |  struct */
#define PGREQ_MKTHEME      9   /* Load a compiled theme          |  theme  */
#define PGREQ_MKCURSOR     10  /* Create a cursor object         |   none  */
#define PGREQ_MKINFILTER   11  /* Create an input filter         |  struct */
#define PGREQ_GETRESOURCE  12  /* Get a pgserver resource handle |  struct */
#define PGREQ_WAIT         13  /* Wait for an event              |  none   */
#define PGREQ_MKFILLSTYLE  14  /* Load a fill style,return handle|  fillstyle */
#define PGREQ_REGISTER     15  /* Register a new application     |  struct */
#define PGREQ_UNUSED_1     16 
#define PGREQ_SIZETEXT     17  /* Find the size of text          |  struct */
#define PGREQ_BATCH        18  /* Executes many requests         |  requests */
#define PGREQ_REGOWNER     19  /* Get exclusive privileges       |  struct */
#define PGREQ_UNREGOWNER   20  /* Give up exclusive privileges   |  struct */
#define PGREQ_SETMODE      21  /* Sets video mode/depth/rotation |  struct */
#define PGREQ_GETMODE      22  /* Returns a modeinfo struct      |  none */
#define PGREQ_MKCONTEXT    23  /* Enters a new context           |  none */
#define PGREQ_RMCONTEXT    24  /* Cleans up and kills the context|  struct */
#define PGREQ_FOCUS        25  /* Force focus to specified widget|  handle */
#define PGREQ_GETSTRING    26  /* Returns a RESPONSE_DATA        |  handle */
#define PGREQ_DUP          27  /* Duplicates an object           |  handle */
#define PGREQ_SETPAYLOAD   28  /* Sets an object's payload       |  struct */
#define PGREQ_GETPAYLOAD   29  /* Gets an object's payload       |  handle */
#define PGREQ_CHCONTEXT    30  /* Change a handle's context      |  struct */
#define PGREQ_WRITECMD     31  /* Send a command to a widget     |  handle + data */
#define PGREQ_UPDATEPART   32  /* Updates subtree defined by wgt |  handle */
#define PGREQ_MKARRAY      33  /* Makes a array, returns handle  |    data */  
#define PGREQ_RENDER       34  /* Render gropnode(s) to a bitmap |  struct */
#define PGREQ_NEWBITMAP    35  /* Creates a blank bitmap         |  struct */
#define PGREQ_THLOOKUP     36  /* Perform a theme lookup         |  struct */
#define PGREQ_GETINACTIVE  37  /* get milliseconds of inactivity |    none */
#define PGREQ_SETINACTIVE  38  /* set milliseconds of inactivity |  struct */
#define PGREQ_DRIVERMSG    39  /* Send a message to all drivers  |  struct */
#define PGREQ_LOADDRIVER   40  /* Load input/misc (not video)    |   chars */
#define PGREQ_GETFSTYLE    41  /* Get info on a font style       |  struct */
#define PGREQ_FINDWIDGET   42  /* Get widget handle by name      |   chars */
#define PGREQ_CHECKEVENT   43  /* Return number of queued events |    none */
#define PGREQ_SIZEBITMAP   44  /* Find the size of a bitmap      |  handle */
#define PGREQ_APPMSG       45  /* Send PG_WE_APPMSG to any widget|  struct */
#define PGREQ_CREATEWIDGET 46  /* Create widget                  |  struct */
#define PGREQ_ATTACHWIDGET 47  /* Attach widget                  |  struct */
#define PGREQ_FINDTHOBJ    48  /* Find theme object by name      |   chars */
#define PGREQ_TRAVERSEWGT  49  /* Find widgets after this one    | struct */
#define PGREQ_MKTEMPLATE   50  /* Load a Widget Template         |      wt */
#define PGREQ_SETCONTEXT   51  /* Set the app's current context  | struct */
#define PGREQ_GETCONTEXT   52  /* Return the current context     |   none */
#define PGREQ_INFILTERSEND 53  /* Send a trigger to an infilter  | struct */
#define PGREQ_MKSHMBITMAP  54  /* Return struct pgshmbitmap      | struct */
#define PGREQ_WRITEDATA    55  /* Stream data to a widget        |  handle + data */

/* NOTE: Before adding new entries to the end, replace any deprecated entries above */

#define PGREQ_UNDEF        56  /* types > this will be truncated. return error */

/******* Request data structures */

/* Structures passed to request handlers as 'data'.
 * Dummy variables pad it to a multiple of 4 bytes (compiler likes it?)
 *
 * All numerical values here are in network byte order (converted with
 * ntohl/ntohs/htonl/htons)
 *
 * All values referring to objects (text,widget,font...) are handles
 * (also in network order)
 *
 */

struct pgreqd_handlestruct {
  u32 h;   /* for requests that just use a handle */
};

struct pgreqd_createwidget {
   u16 type;
   u16 dummy;   /* pad to 32-bit */
};
struct pgreqd_attachwidget {
   u32 parent;
   u32 widget;
   u16 rship;
   u16 dummy;   /* pad to 32-bit */
};

struct pgreqd_mkwidget {
  u16 rship;
  u16 type;
  u32 parent;
};
struct pgreqd_mkfont {
  char name[40];
  u32 style;
  u16 size;
  u16 dummy;
};
struct pgreqd_set {
  u32 widget;
  u32 glob;
  u16 property;
  u16 dummy;
};
struct pgreqd_get {
  u32 widget;
  u16 property;
  u16 dummy;
};
struct pgreqd_in_key {
  u32 type;   /* A PG_TRIGGER_* constant */
  u16 key;
  u16 mods;
};
struct pgreqd_in_point {
  u32 type;   /* A PG_TRIGGER_* constant */
  u16 x;
  u16 y;
  u16 btn;  /* button bitmask */
  u16 dummy;
};
struct pgreqd_in_direct {
  u32 param;   /* The arbitrary parameter */
  /* The rest of the packet is read as a string */
};
struct pgreqd_themeset {
  u32 value;
  u16 element;
  u16 state;
  u16 param;
  u16 dummy;
};
struct pgreqd_register {
  /* This is just a subset of app_info, organized for network
     transmission */

  u32 name;  /* string handle */
  u16 type;
  u16 dummy;

  /* Followed by optional APPSPECs */
};
struct pgreqd_setmode {
  u16 xres;      /* If these are zero, mode is not changed */
  u16 yres;
  u16 bpp;       /* Zero to leave alone */
  u16 flagmode;  /* A PG_FM_* constant */
  u32 flags;     /* Merged with existing flags according to flagmode */
};
struct pgreqd_sizetext {
  u32 text;  /* Handle to text and to font */
  u32 font;
};
struct pgreqd_setpayload {
  u32 h;        /* Any handle */
  u32 payload;  /* 32-bits of data to store with
			     the handle'd object */
};
struct pgreqd_mkmsgdlg {
  u32 title;
  u32 text;
  u32 flags;
};
struct pgreqd_regowner {
  u16 res;     /* A resource to own: PG_OWN_* */
};
struct pgreqd_render {
  /* Handle of a bitmap to render to. If this is null,
   * _and_ the client has been registered as owning the display,
   * the destination will be vid->display
   */
  u32 dest;
  u32 groptype;    /* PG_GROP_* constant */

  /* Followed by a number of 32-bit parameters.
   * like PGCANVAS_GROP, the first four must be x,y,w,h unless it is an
   * unpositioned gropnode. The rest are treated as gropnode parameters.
   */
};
struct pgreqd_newbitmap {
  u16 width;
  u16 height;
};
struct pgreqd_thlookup {
  u16 object;
  u16 property;
};
struct pgreqd_setinactive {
  u32 time;
};
struct pgreqd_drivermsg {
  u32 message;
  u32 param;
};
struct pgreqd_chcontext {
  u32 handle;
  s16 delta;   /* Add this value to the context, may be negative */
  u16 dummy;
};
struct pgreqd_getfstyle {
  /* The index of a font style, in the order that it has been
   * compiled/loaded into pgserver. Starts with zero, increment it until
   * an invalid font style is returned 
   */
  u16 index;
  u16 dummy;
};
struct pgreqd_traversewgt {
  u32 widget;
  u16 direction;                /* PG_TRAVERSE_* flag */
  u16 count;
};
struct pgreqd_rmcontext {
  /* This entire structure is optional.
   * If it's absent, this removes the app's current context and 
   * decrements. If it's here, the specified context is removed
   * and the app's context number is left alone.
   */
  u32 context;
};
struct pgreqd_setcontext {
  u32 context;
};
struct pgreqd_getresource {
  u32 id;
};
struct pgreqd_mkinfilter {
  u32 insert_after;        /* Handle of the filter to insert this one after, or 0
			    * for this filter to be the first in the chain.
			    */
  u32 accept_trigs;        /* Mask of triggers that this filter should accept */
  u32 absorb_trigs;        /* Mask of triggers not to automatically pass on   */
};
struct pgreqd_infiltersend {
  union pg_client_trigger trig;
};
struct pgreqd_mkshmbitmap {
  u32 bitmap;    /* Bitmap handle to memory map */
  u32 uid;       /* UID of the client process   */
};


struct pgdata_getfstyle {
  /* This is returned by getfstyle.
   * If name[0] is 0, the font style index was invalid
   */
  char name[40];          /* Name of the font family */
  unsigned short size;    /* Height in pixels (for bitmapped fonts) */
  unsigned short fontrep; /* PG_FR_* flags for font representation */
  unsigned long  flags;   /* PG_FSTYLE_* flags for font style itself */
};

/* Returned by rqh_getmode */
struct pgmodeinfo {
   u32 flags;
   u16 xres;     /* Physical resolution */
   u16 yres;
   u16 lxres;    /* Logical resolution */
   u16 lyres;
   u16 bpp;  
   u16 dummy;
};

/* Returned by rqh_mkshmbitmap, represents a picogui bitmap
 * that has been exported as shared memory. The returned SHM key
 * will be valid as long as the bitmap it was created from exists.
 * This structure supplies as much information about the bitmap's
 * internal representation as possible, as the client must manipulate
 * the bitmap in our video driver's native format, whatever that
 *  might be. All values here are in network byte order.
 */
struct pgshmbitmap {
  u32 shm_key;             /* System V shared memory key          */
  u32 shm_length;          /* Length in bytes of shared segment   */

  u32 format;              /* PG_BITFORMAT_* flags                */
  u32 palette;             /* A handle to the associated palette  */

  u16 width;               /* Physical resolution of bitmap       */
  u16 height;              /*   (doesn't account for rotation)    */
  u16 bpp;
  u16 pitch;

  u32 red_mask;            /* For true color modes, masks of bits */
  u32 green_mask;          /*   occupied by all the color fields  */
  u32 blue_mask;
  u32 alpha_mask;

  u16 red_shift;           /* For true color modes, number of     */
  u16 green_shift;         /*   bits each color field is shifted  */
  u16 blue_shift;          /*   left.                             */
  u16 alpha_shift;

  u16 red_length;          /* For true color modes, length        */
  u16 green_length;        /*   in bits of each color field       */
  u16 blue_length;
  u16 alpha_length;
};
   
#endif /* __H_PG_NETWORK */
/* The End */
