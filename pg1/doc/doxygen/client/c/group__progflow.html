<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Program Flow</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Program Flow<br>
<small>
[<a class="el" href="group__pgapi.html">Core PicoGUI API</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a0">pgEventLoop</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Event processing and dispatching loop.</em> <a href="#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a1">pgExitEventLoop</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Exit the current event loop.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpg_event.html">pgEvent</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a2">pgGetEvent</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Wait for a single event.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a3">pgCheckEvent</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check the number of pending events.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a4">pgDispatchEvent</a> (struct <a class="el" href="structpg_event.html">pgEvent</a> *evt)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dispatch an event to registered handlers.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a5">pgEventPoll</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get and dispatch new events if there are any.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a6">pgEnterContext</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Enter a new context.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a7">pgLeaveContext</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Leave a context.</em> <a href="#a7"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a8">pgDeleteHandleContext</a> (int id)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Delete all handles in one context.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a9">pgSetContext</a> (int id)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the context ID used when creating new handles.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__progflow.html#a10">pgGetContext</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the current context ID.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Event loops and handle contexts <hr><h2>Function Documentation</h2>
<a name="a3" doxytag="client_c.h::pgCheckEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgCheckEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check the number of pending events.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of events in the application's queue</dd></dl>
The PicoGUI server keeps a ring buffer of waiting events for each client connected to it. This function returns the number of events waiting in this buffer. Note that this buffer is usually relatively small. At the time of this writing, it is set to hold 16 events. If the buffer is full, old events will be discarded.<p>
You can use this function if, for some reason, you need to poll PicoGUI events instead of waiting for them. In the middle of a long operation, for example, you may wish to periodically check if the user clicks a cancel button. If this function indicates that there are events waiting, pgGetEvent will return immediately with the oldest queued event.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a2">pgGetEvent</a>, <a class="el" href="group__progflow.html#a0">pgEventLoop</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="client_c.h::pgDeleteHandleContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgDeleteHandleContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete all handles in one context.
<p>
This lets you use contexts as individuals with an ID rather than as a stack. <a class="el" href="group__progflow.html#a7">pgLeaveContext()</a> deletes the current context (stored per-connection) and decrements that current context. This function deletes the specified context without touching the current context number. This way new contexts can be requested and discarded indefinitely (or at least until the IDs wrap around, in which case the server will skip context nubmers that are in use)<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a6">pgEnterContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="client_c.h::pgDispatchEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgDispatchEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpg_event.html">pgEvent</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>evt</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dispatch an event to registered handlers.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>evt</em>&nbsp;</td><td>Pointer to the event to dispatch. This should not be the same pointer returned by <a class="el" href="group__progflow.html#a2">pgGetEvent()</a>, as it is only valid until the next PicoGUI call! See <a class="el" href="group__progflow.html#a2">pgGetEvent()</a> for more information.</td></tr>
  </table>
</dl>
This function searches all registered event handlers, and dispatches the event to any applicable handlers. It also provides various default handlers, such as closing the program on recieving PG_WE_CLOSE.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a2">pgGetEvent</a>, <a class="el" href="group__progflow.html#a3">pgCheckEvent</a>, <a class="el" href="group__progflow.html#a0">pgEventLoop</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a6" doxytag="client_c.h::pgEnterContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgEnterContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enter a new context.
<p>
PicoGUI uses a context system, similar to a variable's scope in C. Whenever the program leaves a context, all objects created while in that context are deleted. No memory is used by creating a context, and they can be nested a very large number of times.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the ID of the new context</dd></dl>
Here is an example, indented to show the context levels: <div class="fragment"><pre>
pghandle x,y,z;

<a class="code" href="group__progflow.html#a3">pgEnterContext</a>();
  x = <a class="code" href="group__pgobjects.html#a40">pgNewString</a>(<span class="stringliteral">"X"</span>);
  <a class="code" href="group__progflow.html#a3">pgEnterContext</a>();
    y = <a class="code" href="group__pgobjects.html#a40">pgNewString</a>(<span class="stringliteral">"Y"</span>);
  <a class="code" href="group__progflow.html#a5">pgLeaveContext</a>();           <span class="comment">// y is deleted</span>
  z = <a class="code" href="group__pgobjects.html#a40">pgNewString</a>(<span class="stringliteral">"Z"</span>);
<a class="code" href="group__progflow.html#a5">pgLeaveContext</a>();             <span class="comment">// x and z are deleted</span>
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a7">pgLeaveContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a0" doxytag="client_c.h::pgEventLoop"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgEventLoop </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Event processing and dispatching loop.
<p>
pgEventLoop waits for events from the PicoGUI server and dispatches them according to bindings set up with pgBind. The handler set with pgSetIdle is also called if applicable.<p>
pgEventLoop can be called more than once throughout the life of the program, but it is not re-entrant.<p>
If the app recieves an event while it is not waiting in an EventLoop, the server will queue them until the client is ready.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a2">pgGetEvent</a>, <a class="el" href="group__progflow.html#a1">pgExitEventLoop</a>, <a class="el" href="group__admin.html#a8">pgBind</a>, <a class="el" href="group__admin.html#a4">pgSetIdle</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="client_c.h::pgEventPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgEventPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get and dispatch new events if there are any.
<p>
This function is a non-blocking version of <a class="el" href="group__progflow.html#a0">pgEventLoop()</a>. It calls <a class="el" href="group__progflow.html#a3">pgCheckEvent()</a>, and if there are any new events it uses <a class="el" href="group__progflow.html#a2">pgGetEvent()</a> and <a class="el" href="group__progflow.html#a4">pgDispatchEvent()</a> to retrieve and process any pending events.<p>
This is good to call during an animation or other lengthy operation to check for the user clicking the close button, canceling the operation, etc.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a2">pgGetEvent</a>, <a class="el" href="group__progflow.html#a3">pgCheckEvent</a>, <a class="el" href="group__progflow.html#a4">pgDispatchEvent</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="client_c.h::pgExitEventLoop"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgExitEventLoop </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exit the current event loop.
<p>
If the client is currently inside an event loop, this function sets a flag to exit it at the next possible opportunity<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a0">pgEventLoop</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="client_c.h::pgGetContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgGetContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current context ID.
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a8">pgDeleteHandleContext</a>, <a class="el" href="group__progflow.html#a6">pgEnterContext</a>, <a class="el" href="group__progflow.html#a7">pgLeaveContext</a>, <a class="el" href="group__progflow.html#a9">pgSetContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="client_c.h::pgGetEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpg_event.html">pgEvent</a>* pgGetEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a single event.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="structpg_event.html">pgEvent</a> structure</dd></dl>
This is good for small dialog boxes, or other situations when pgBind and pgEventLoop are overkill. pgGetEvent can be used while an event loop is already in progress, for example in a pgSetIdle or pgBind handler function.<p>
You can also use this in combination with pgCheckEvent to passively check for new events while performing some other operation, such as animation.<p>
Important! Note that the returned pointer is only valid until the next PicoGUI call! It's usually a good idea to use something like this:<p>
<div class="fragment"><pre>

<span class="keyword">struct </span><a class="code" href="structpg_event.html">pgEvent</a> evt;

evt = *<a class="code" href="group__progflow.html#a38">pgGetEvent</a>();

 
</pre></div><p>
If the relevant values from the <a class="el" href="structpg_event.html">pgEvent</a> structure will be copied elsewhere before the next PicoGUI call, that is alright too. Thus, the following code is perfectly fine:<p>
<div class="fragment"><pre>

i = <a class="code" href="group__pgobjects.html#a20">pgGetPayload</a>( <a class="code" href="group__progflow.html#a38">pgGetEvent</a>()-&gt;from );

 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a0">pgEventLoop</a>, <a class="el" href="group__admin.html#a8">pgBind</a>, <a class="el" href="group__admin.html#a4">pgSetIdle</a>, <a class="el" href="group__pgobjects.html#a33">pgSetPayload</a>, <a class="el" href="group__pgobjects.html#a34">pgGetPayload</a>, <a class="el" href="group__progflow.html#a3">pgCheckEvent</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a7" doxytag="client_c.h::pgLeaveContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgLeaveContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Leave a context.
<p>
When leaving a context, all objects created within it are deleted, and the context ID is decremented. This default behavior simulates a stack of contexts. See pgEnterContext for an example.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a6">pgEnterContext</a>, <a class="el" href="group__progflow.html#a8">pgDeleteHandleContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="client_c.h::pgSetContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSetContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the context ID used when creating new handles.
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__progflow.html#a8">pgDeleteHandleContext</a>, <a class="el" href="group__progflow.html#a6">pgEnterContext</a>, <a class="el" href="group__progflow.html#a7">pgLeaveContext</a>, <a class="el" href="group__progflow.html#a10">pgGetContext</a> </dd></dl>
    </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Fri May 23 03:39:45 2003 for PicoGUI by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
