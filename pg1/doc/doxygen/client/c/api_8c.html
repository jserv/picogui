<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>api.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/home/micah/picogui/pg1/client/c/src/api.c File Reference</h1><code>#include "<a class="el" href="clientlib_8h-source.html">clientlib.h</a>"</code><br>
<code>#include &lt;sys/types.h&gt;</code><br>
<code>#include &lt;sys/stat.h&gt;</code><br>
<code>#include &lt;unistd.h&gt;</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a0">DBG</a>(fmt, args...)&nbsp;&nbsp;&nbsp;printf( "%s: " fmt, __FUNCTION__ , ## args); fflush(stdout)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a1">PGDM_INPUT_RAW</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a2">pgUpdate</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Update the screen.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a3">pgEnterContext</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Enter a new context.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a4">pgGetContext</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the current context ID.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a5">pgLeaveContext</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Leave a context.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a6">pgSetContext</a> (int id)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the context ID used when creating new handles.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a7">pgDeleteHandleContext</a> (int id)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Delete all handles in one context.</em> <a href="#a7"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a8">pgDataString</a> (struct <a class="el" href="structpgmemdata.html">pgmemdata</a> obj)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Load memory into a string handle.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a9">pgLoadTheme</a> (struct <a class="el" href="structpgmemdata.html">pgmemdata</a> obj)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Load a compiled theme.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a10">pgLoadWidgetTemplate</a> (struct <a class="el" href="structpgmemdata.html">pgmemdata</a> obj)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Load a compiled Widget Template.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u32&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a11">pgThemeLookup</a> (s16 object, s16 property)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Retrieve a theme property.</em> <a href="#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a12">pgFromMemory</a> (void *data, u32 length)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Refer to data loaded into memory.</em> <a href="#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a13">pgFromTempMemory</a> (void *data, u32 length)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Refer to data loaded into memory, free when done.</em> <a href="#a13"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a14">pgFromFile</a> (const char *file)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Refer to data in a file.</em> <a href="#a14"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a15">pgFromStream</a> (FILE *f, u32 length)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Refer to data in an opened stream.</em> <a href="#a15"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a16">pgSetPayload</a> (pghandle object, u32 payload)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set an object's payload.</em> <a href="#a16"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a17">pgRegisterOwner</a> (int resource)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Register exclusive access to a resouce.</em> <a href="#a17"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a18">pgUnregisterOwner</a> (int resource)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Unregister exclusive access to a resouce.</em> <a href="#a18"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a19">pgSetVideoMode</a> (u16 xres, u16 yres, u16 bpp, u16 flagmode, u32 flags)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Change video mode at runtime.</em> <a href="#a19"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u32&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a20">pgGetPayload</a> (pghandle object)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get an object's payload.</em> <a href="#a20"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a21">pgGetServerRes</a> (u32 res)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get a server resource.</em> <a href="#a21"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a22">pgSetInactivity</a> (u32 time)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set the inactivity timer.</em> <a href="#a22"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>u32&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a23">pgGetInactivity</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the inactivity timer.</em> <a href="#a23"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a24">pgNewCursor</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a cursor that can be used for input filters.</em> <a href="#a24"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a25">pgSubUpdate</a> (pghandle widget)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Update a subsection of the screen.</em> <a href="#a25"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a26">pgFocus</a> (pghandle widget)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Give a widget the keyboard focus.</em> <a href="#a26"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a27">pgDelete</a> (pghandle object)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Delete any object that has a handle.</em> <a href="#a27"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a28">pgRegisterApp</a> (s16 type, const char *name,...)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Register a new application.</em> <a href="#a28"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a29">pgSetWidget</a> (pghandle widget,...)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Set widget properties.</em> <a href="#a29"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a30">pgCreateWidget</a> (s16 type)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new widget without a parent.</em> <a href="#a30"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a31">pgNewInFilter</a> (pghandle insert_after, u32 accept_trigs, u32 absorb_trigs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new client-side input filter.</em> <a href="#a31"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a32">pgAttachWidget</a> (pghandle parent, s16 rship, pghandle widget)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Attach a widget to a new parent.</em> <a href="#a32"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a33">pgInFilterSend</a> (union pg_client_trigger *trig)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send an event back from a client-side input filter.</em> <a href="#a33"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a34">pgNewWidget</a> (s16 type, s16 rship, pghandle parent)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new widget, derived from a parent widget.</em> <a href="#a34"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a35">pgNewPopupAt</a> (int x, int y, int width, int height)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a popup box at the specified position.</em> <a href="#a35"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a36">pgNewFont</a> (const char *name, s16 size, u32 style)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new font object.</em> <a href="#a36"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a37">pgNewPopup</a> (int width, int height)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a popup box, centered on the screen.</em> <a href="#a37"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a38">pgNewBitmap</a> (struct <a class="el" href="structpgmemdata.html">pgmemdata</a> obj)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new bitmap object from existing data.</em> <a href="#a38"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a39">pgCreateBitmap</a> (s16 width, s16 height)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new bitmap object.</em> <a href="#a39"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a40">pgNewString</a> (const char *str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new string object.</em> <a href="#a40"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a41">pgFindWidget</a> (const char *str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Search for a widget by its PG_WP_NAME property.</em> <a href="#a41"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a42">pgFindThemeObject</a> (const char *str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Find a theme object's ID given its name.</em> <a href="#a42"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a43">pgNewArray</a> (const s32 *dat, u16 size)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new array object.</em> <a href="#a43"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a44">pgEvalRequest</a> (s16 reqtype, void *data, u32 datasize)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Evaluate a PicoGUI request packet.</em> <a href="#a44"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>s32&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a45">pgGetWidget</a> (pghandle widget, s16 property)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get a widget property.</em> <a href="#a45"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a46">pgTraverseWidget</a> (pghandle widget, int direction, int count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Finds a widget in relation to another widget.</em> <a href="#a46"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a47">pgSizeText</a> (int *w, int *h, pghandle font, pghandle text)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Measure a string of text.</em> <a href="#a47"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a48">pgSizeBitmap</a> (int *w, int *h, pghandle bitmap)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the size of a bitmap object.</em> <a href="#a48"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a49">pgGetString</a> (pghandle string)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the contents of a string handle.</em> <a href="#a49"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pgshmbitmap *&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a50">pgMakeSHMBitmap</a> (pghandle bitmap)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Map a bitmap into a shared memory segment.</em> <a href="#a50"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a51">pgGetFontStyle</a> (s16 index, char *name, u16 *size, u16 *fontrep, u32 *flags)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get information about a font style.</em> <a href="#a51"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pgmodeinfo *&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a52">pgGetVideoMode</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get information about the current video mode.</em> <a href="#a52"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a53">pgDriverMessage</a> (u32 message, u32 param)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a message to the drivers.</em> <a href="#a53"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a54">pgReplaceText</a> (pghandle widget, const char *str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Change a widget's text.</em> <a href="#a54"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a55">pgReplaceTextFmt</a> (pghandle widget, const char *fmt,...)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Change a widget's text, with formatting.</em> <a href="#a55"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a56">pgWriteData</a> (pghandle widget, struct <a class="el" href="structpgmemdata.html">pgmemdata</a> data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Write data to a widget.</em> <a href="#a56"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a57">pgWriteCmd</a> (pghandle widget, s32 command, s16 numparams,...)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Write a command to a widget.</em> <a href="#a57"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a58">pgRender</a> (pghandle bitmap, s16 groptype,...)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Render a gropnode to a bitmap.</em> <a href="#a58"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a59">pgLoadDriver</a> (const char *name)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Load an input driver by name and return a handle.</em> <a href="#a59"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>pghandle&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a60">pgDup</a> (pghandle object)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Duplicate an object that has a handle.</em> <a href="#a60"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a61">pgChangeContext</a> (pghandle object, s16 delta)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Change the handle context of an object.</em> <a href="#a61"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a62">pgCheckEvent</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Check the number of pending events.</em> <a href="#a62"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a63">pgEventPoll</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get and dispatch new events if there are any.</em> <a href="#a63"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a64">pgAppMessage</a> (pghandle dest, struct <a class="el" href="structpgmemdata.html">pgmemdata</a> data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a message to a widget owned by any application.</em> <a href="#a64"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="api_8c.html#a66">pgSyncAppMessage</a> (pghandle dest, struct <a class="el" href="structpgmemdata.html">pgmemdata</a> data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Send a message to a widget owned by any application, and wait for an answer.</em> <a href="#a66"></a><em></em></font><br><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a name="a0" doxytag="api.c::DBG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DBG</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">fmt,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>args...&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;printf( "%s: " fmt, __FUNCTION__ , ## args); fflush(stdout)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="api.c::PGDM_INPUT_RAW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PGDM_INPUT_RAW&nbsp;&nbsp;&nbsp;8
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a64" doxytag="api.c::pgAppMessage"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgAppMessage </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a message to a widget owned by any application.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dest</em>&nbsp;</td><td>Handle of the destination widget </td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>A pgmemdata structure containing the data, as returned by a pgFrom* function</td></tr>
  </table>
</dl>
The <code>data</code> parameter is sent as the <code>data</code> in a PG_WE_APPMSG event on behalf of the <code>dest</code> widget.     </td>
  </tr>
</table>
<a name="a32" doxytag="api.c::pgAttachWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgAttachWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>parent</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rship</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attach a widget to a new parent.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>parent</em>&nbsp;</td><td>The parent widget's handle, or PGDEFAULT. </td></tr>
    <tr><td valign=top><em>rship</em>&nbsp;</td><td>A PG_DERIVE_* constant indicating the new widget's relationship to it's parent. It can be PGDEFAULT. </td></tr>
    <tr><td valign=top><em>widget</em>&nbsp;</td><td>The widget to attach</td></tr>
  </table>
</dl>
This is necessary if you earlier created a widget using pgCreateWidget and now need to attach it to a parent, or if you want to reattach a widget to a different parent. If the widget has any subwidgets, they are moved along with the specified widget.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a30">pgCreateWidget</a>, pgDeleteWidget </dd></dl>
    </td>
  </tr>
</table>
<a name="a61" doxytag="api.c::pgChangeContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgChangeContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>object</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>delta</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the handle context of an object.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A handle to any PicoGUI object </td></tr>
    <tr><td valign=top><em>delta</em>&nbsp;</td><td>The value to add to the context level</td></tr>
  </table>
</dl>
A positive delta value increases the object's context, equivalent to adding extra <a class="el" href="api_8c.html#a3">pgEnterContext()</a> layers. The delta value may be negative, to 'send' the handle to a higher-level context. For example, you may want to return data from a dialog box: <div class="fragment"><pre>
<a class="code" href="api_8c.html#a3">pgEnterContext</a>();
<a class="code" href="group__stddialog.html#a0">pgDialogBox</a>(<span class="stringliteral">"My Dialog"</span>);
... Allocate lots of memory ...
pgChangeContext(important_data,-1);
<a class="code" href="api_8c.html#a5">pgLeaveContext</a>();
<span class="keywordflow">return</span> important_data;
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a62" doxytag="api.c::pgCheckEvent"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgCheckEvent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check the number of pending events.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of events in the application's queue</dd></dl>
The PicoGUI server keeps a ring buffer of waiting events for each client connected to it. This function returns the number of events waiting in this buffer. Note that this buffer is usually relatively small. At the time of this writing, it is set to hold 16 events. If the buffer is full, old events will be discarded.<p>
You can use this function if, for some reason, you need to poll PicoGUI events instead of waiting for them. In the middle of a long operation, for example, you may wish to periodically check if the user clicks a cancel button. If this function indicates that there are events waiting, pgGetEvent will return immediately with the oldest queued event.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="netcore_8c.html#a38">pgGetEvent</a>, <a class="el" href="netcore_8c.html#a35">pgEventLoop</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a39" doxytag="api.c::pgCreateBitmap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgCreateBitmap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new bitmap object.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>width</em>&nbsp;</td><td>Width, in pixels, of the new bitmap </td></tr>
    <tr><td valign=top><em>height</em>&nbsp;</td><td>Height, in pixels, of the new bitmap </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new bitmap object. It's contents are undefined</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a38">pgNewBitmap</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a30" doxytag="api.c::pgCreateWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgCreateWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s16&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>type</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new widget without a parent.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>type</em>&nbsp;</td><td>A PG_WIDGET_* constant for the widget type</td></tr>
  </table>
</dl>
This function creates a widget, but does not attach it to the parent widget. You can still set the widget's parameters and attach child widgets to this one, but the widget cannot be drawn until you call pgAttachWidget.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a32">pgAttachWidget</a>, <a class="el" href="api_8c.html#a34">pgNewWidget</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="api.c::pgDataString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgDataString </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>obj</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load memory into a string handle.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>A pgmemdata structure, as returned by a pgFrom* function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new string object created in the PicoGUI server</dd></dl>
This is like <a class="el" href="api_8c.html#a40">pgNewString()</a> except that the string is loaded from a pgmemdata structure, and it does not need to be null-terminated. This makes it easy to load text files, for instance.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, <a class="el" href="api_8c.html#a27">pgDelete</a>, <a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="api.c::pgDelete"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgDelete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>object</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete any object that has a handle.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A handle to any type of object (String, widget, bitmap, etc.)</td></tr>
  </table>
</dl>
This function frees the memory in the PicoGUI server associated with <code>object.</code>     </td>
  </tr>
</table>
<a name="a7" doxytag="api.c::pgDeleteHandleContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgDeleteHandleContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete all handles in one context.
<p>
This lets you use contexts as individuals with an ID rather than as a stack. <a class="el" href="api_8c.html#a5">pgLeaveContext()</a> deletes the current context (stored per-connection) and decrements that current context. This function deletes the specified context without touching the current context number. This way new contexts can be requested and discarded indefinitely (or at least until the IDs wrap around, in which case the server will skip context nubmers that are in use)<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a3">pgEnterContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a53" doxytag="api.c::pgDriverMessage"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgDriverMessage </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>message</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>param</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a message to the drivers.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>message</em>&nbsp;</td><td>A PGDM_* driver message constant </td></tr>
    <tr><td valign=top><em>param</em>&nbsp;</td><td>Defined by the type of message sent</td></tr>
  </table>
</dl>
This command can send 'extra' commands that may be hardware-specific, like beeps, cursor blanking, and backlight control.     </td>
  </tr>
</table>
<a name="a60" doxytag="api.c::pgDup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgDup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>object</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Duplicate an object that has a handle.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A handle to one of several types of PicoGUI objects</td></tr>
  </table>
</dl>
Some objects simply can't be duplicated: For example, it would not make sense to duplicate a widget, driver, or theme. At the time of this writing, the only object type for which duplication is implemented is the string object.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a27">pgDelete</a>, <a class="el" href="api_8c.html#a40">pgNewString</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="api.c::pgEnterContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgEnterContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enter a new context.
<p>
PicoGUI uses a context system, similar to a variable's scope in C. Whenever the program leaves a context, all objects created while in that context are deleted. No memory is used by creating a context, and they can be nested a very large number of times.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the ID of the new context</dd></dl>
Here is an example, indented to show the context levels: <div class="fragment"><pre>
pghandle x,y,z;

<a class="code" href="api_8c.html#a3">pgEnterContext</a>();
  x = <a class="code" href="api_8c.html#a40">pgNewString</a>(<span class="stringliteral">"X"</span>);
  <a class="code" href="api_8c.html#a3">pgEnterContext</a>();
    y = <a class="code" href="api_8c.html#a40">pgNewString</a>(<span class="stringliteral">"Y"</span>);
  <a class="code" href="api_8c.html#a5">pgLeaveContext</a>();           <span class="comment">// y is deleted</span>
  z = <a class="code" href="api_8c.html#a40">pgNewString</a>(<span class="stringliteral">"Z"</span>);
<a class="code" href="api_8c.html#a5">pgLeaveContext</a>();             <span class="comment">// x and z are deleted</span>
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a5">pgLeaveContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a44" doxytag="api.c::pgEvalRequest"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgEvalRequest </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>reqtype</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>datasize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Evaluate a PicoGUI request packet.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>reqtype</em>&nbsp;</td><td>A PGREQ_* constant indicating the packet type </td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>Pointer to the raw packet data </td></tr>
    <tr><td valign=top><em>datasize</em>&nbsp;</td><td>Length of raw packet data</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the request packet's return value, if any. If the request packet does not return a simple data type, the value is undefined.</dd></dl>
This is a good way to reuse PicoGUI's serialization capabilities to load a generic binary object from file. It is advisable to validate the request's type first so you don't allow the input to do wierd things like change video mode or leave the current context.<p>
The format of the data accepted by the request packet depends on the type of packet.     </td>
  </tr>
</table>
<a name="a63" doxytag="api.c::pgEventPoll"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgEventPoll </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get and dispatch new events if there are any.
<p>
This function is a non-blocking version of <a class="el" href="group__progflow.html#a0">pgEventLoop()</a>. It calls <a class="el" href="api_8c.html#a62">pgCheckEvent()</a>, and if there are any new events it uses <a class="el" href="group__progflow.html#a2">pgGetEvent()</a> and <a class="el" href="group__progflow.html#a4">pgDispatchEvent()</a> to retrieve and process any pending events.<p>
This is good to call during an animation or other lengthy operation to check for the user clicking the close button, canceling the operation, etc.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="netcore_8c.html#a38">pgGetEvent</a>, <a class="el" href="api_8c.html#a62">pgCheckEvent</a>, <a class="el" href="netcore_8c.html#a36">pgDispatchEvent</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a42" doxytag="api.c::pgFindThemeObject"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgFindThemeObject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>key</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find a theme object's ID given its name.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>key</em>&nbsp;</td><td>The "name" property to search for </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The theme ID, or zero if it's not found</dd></dl>
This function is useful for finding custom theme objects. Theme objects defined as <code>custom</code> are assigned an ID automatically at load time. These objects can be found with this function as long as each is assigned a unique <code>name</code> property.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a9">pgLoadTheme</a>, <a class="el" href="api_8c.html#a41">pgFindWidget</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a41" doxytag="api.c::pgFindWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgFindWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>key</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Search for a widget by its PG_WP_NAME property.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>key</em>&nbsp;</td><td>The name to search for </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The handle of the found widget, or zero if no widget matches the supplied name</dd></dl>
Every widget can be given a name by setting it's PG_WP_NAME property to a string handle. This function can search for a widget's handle based on this name. Note that this function will search all widgets, even those not owned by this application.<p>
<dl compact><dt><b>See also:</b></dt><dd>PG_WP_NAME, <a class="el" href="api_8c.html#a29">pgSetWidget</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a26" doxytag="api.c::pgFocus"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgFocus </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>widget</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Give a widget the keyboard focus.
<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="api.c::pgFromFile"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpgmemdata.html">pgmemdata</a> pgFromFile </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>file</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Refer to data in a file.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>file</em>&nbsp;</td><td>The name of the file containing data to be referred to </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pgmemdata structure describing the data. This is needed by many PicoGUI API functions that require data as input.</dd></dl>
Depending on implementation the file may be loaded into memory temporarily, or memory-mapped if possible<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a12" doxytag="api.c::pgFromMemory"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpgmemdata.html">pgmemdata</a> pgFromMemory </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Refer to data loaded into memory.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>data</em>&nbsp;</td><td>A pointer to data loaded into memory </td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The length, in bytes, of the data referred to </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pgmemdata structure describing the data</dd></dl>
When using pgFromMemory, the data pointer must remain valid for a relatively long period of time, usually until the request buffer is flushed. If you would rather have the client library free the memory for you when it is done, see pgFromTempMemory<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="api.c::pgFromStream"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpgmemdata.html">pgmemdata</a> pgFromStream </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Refer to data in an opened stream.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>f</em>&nbsp;</td><td>C stream, as returned by <code>fopen()</code> in <code>stdio.h</code> </td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The number of bytes to read from the stream </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pgmemdata structure describing the data</dd></dl>
Depending on implementation, the data may be read from the stream into memory, or memory-mapped if possible. The chunk of data referred to begins at the stream's current position and extends <code>length</code> bytes past it. The stream's position is advanced by <code>length</code> bytes.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="api.c::pgFromTempMemory"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct <a class="el" href="structpgmemdata.html">pgmemdata</a> pgFromTempMemory </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Refer to data loaded into memory, free when done.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>data</em>&nbsp;</td><td>A pointer to data loaded into memory </td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The length, in bytes, of the data referred to </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pgmemdata structure describing the data</dd></dl>
The data pointer must have been dynamically allocated with malloc() or equivalent. When the client library is done using it, <code>data</code> will be freed with the free() function.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="api.c::pgGetContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgGetContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current context ID.
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a7">pgDeleteHandleContext</a>, <a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a>, <a class="el" href="api_8c.html#a6">pgSetContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a51" doxytag="api.c::pgGetFontStyle"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int pgGetFontStyle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>index</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fontrep</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get information about a font style.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>index</em>&nbsp;</td><td>A zero-based index to select a font style in the order that the were compiled or loaded into pgserver </td></tr>
    <tr><td valign=top><em>name</em>&nbsp;</td><td>Pointer to a buffer to store the font name in. Must be 40 bytes long </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>Pointer that the font size is returned in. For bitmapped fonts (all PicoGUI currently supports) this is height in pixels </td></tr>
    <tr><td valign=top><em>fontrep</em>&nbsp;</td><td>Pointer that the font representation is returned in. This is a combination of one or more PG_FR_* flags. </td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>Pointer that font style flags are returned in. This is a combination of PG_FSTYLE_* flags </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if the index was valid and data was stored in the supplied pointers</dd></dl>
This function can be used to iterate through the available fonts. For example: <div class="fragment"><pre>
<span class="keywordtype">char</span> name[40];
u16 size;
u16 fontrep;
u32 flags;
s16 i;

i = 0;
<span class="keywordflow">while</span> (<a class="code" href="api_8c.html#a51">pgGetFontStyle</a>(i++, name, &amp;size, &amp;fontrep, &amp;flags)) {
   printf(<span class="stringliteral">"Font #%d: %s\n"</span>
          <span class="stringliteral">"    size: %d\n"</span>
          <span class="stringliteral">" fontrep: 0x%04X\n"</span>
          <span class="stringliteral">"   flags: 0x%08X\n\n"</span>,
          i,name,size,fontrep,flags);
}
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a36">pgNewFont</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="api.c::pgGetInactivity"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u32 pgGetInactivity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the inactivity timer.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The inactivity timer value in milliseconds</dd></dl>
This timer is maintained by PicoGUI. It continually increments, but it is cleared whenever user input is recieved and it can be set by pgSetInactivity<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a22">pgSetInactivity</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="api.c::pgGetPayload"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u32 pgGetPayload </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>object</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an object's payload.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A handle to any PicoGUI object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 32-bit piece of application-defined data set using pgSetPayload</dd></dl>
See pgSetPayload for more information about payloads and their uses.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a16">pgSetPayload</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="api.c::pgGetServerRes"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgGetServerRes </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a server resource.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The resource handle associated with the given PGRES_* constant </dd></dl>
    </td>
  </tr>
</table>
<a name="a49" doxytag="api.c::pgGetString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* pgGetString </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>string</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the contents of a string handle.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>string</em>&nbsp;</td><td>Must be a handle to a string object </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the string object's contents</dd></dl>
The returned string pointer must be treated as read-only. It is only valid until the next PicoGUI function call.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a40">pgNewString</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a52" doxytag="api.c::pgGetVideoMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct pgmodeinfo* pgGetVideoMode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get information about the current video mode.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A pgmodeinfo structure with information about the current video mode.</dd></dl>
The returned pointer is good only until the next PicoGUI call. It is recommended to use something like the following:<p>
<div class="fragment"><pre>
<span class="keyword">struct </span>pgmodeinfo mi;
mi = *<a class="code" href="api_8c.html#a52">pgGetVideoMode</a>();
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a19">pgSetVideoMode</a>, pgmodeinfo </dd></dl>
    </td>
  </tr>
</table>
<a name="a45" doxytag="api.c::pgGetWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> s32 pgGetWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>property</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a widget property.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>widget</em>&nbsp;</td><td>Widget handle </td></tr>
    <tr><td valign=top><em>property</em>&nbsp;</td><td>A widget property (PG_WP_* constant)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value associated with the specified property</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a29">pgSetWidget</a>, <a class="el" href="api_8c.html#a34">pgNewWidget</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="api.c::pgInFilterSend"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgInFilterSend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">union pg_client_trigger *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>trig</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send an event back from a client-side input filter.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>trig</em>&nbsp;</td><td>Client-side trigger union, representing the event</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a24">pgNewCursor</a>, <a class="el" href="api_8c.html#a31">pgNewInFilter</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="api.c::pgLeaveContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgLeaveContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Leave a context.
<p>
When leaving a context, all objects created within it are deleted, and the context ID is decremented. This default behavior simulates a stack of contexts. See pgEnterContext for an example.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a7">pgDeleteHandleContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a59" doxytag="api.c::pgLoadDriver"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgLoadDriver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>name</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load an input driver by name and return a handle.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>Driver name as reported by 'pgserver -l'</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the loaded driver </dd></dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="api.c::pgLoadTheme"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgLoadTheme </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>obj</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load a compiled theme.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>A pgmemdata structure, as returned by a pgFrom* function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new theme object created in the PicoGUI server</dd></dl>
The compiled theme data can be generated using the <code>themec</code> utility. The theme can be unloaded by calling pgDelete with the returned theme handle.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, <a class="el" href="api_8c.html#a27">pgDelete</a>, <a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="api.c::pgLoadWidgetTemplate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgLoadWidgetTemplate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>obj</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load a compiled Widget Template.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>A pgmemdata structure, as returned by a pgFrom* function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new Widget Template object created in the PicoGUI server</dd></dl>
This widget template is like a cookie-cutter that can be used to instantiate a whole tree of widgets or other objects. You instantiate the template using <a class="el" href="api_8c.html#a60">pgDup()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, <a class="el" href="api_8c.html#a27">pgDelete</a>, <a class="el" href="api_8c.html#a60">pgDup</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a50" doxytag="api.c::pgMakeSHMBitmap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct pgshmbitmap* pgMakeSHMBitmap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>bitmap</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Map a bitmap into a shared memory segment.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>bitmap</em>&nbsp;</td><td>Handle to the bitmap to map </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pgshmbitmap structure with the SHM key and format info, valid until the next PicoGUI call</dd></dl>
This isn't well documented yet, see picogui/network.h for the pgshmbitmap structure.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a38">pgNewBitmap</a>, <a class="el" href="api_8c.html#a39">pgCreateBitmap</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a43" doxytag="api.c::pgNewArray"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewArray </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const s32 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dat</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new array object.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dat</em>&nbsp;</td><td>The data to put in the array </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>Number of entries in the array </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new array object </dd></dl>
    </td>
  </tr>
</table>
<a name="a38" doxytag="api.c::pgNewBitmap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewBitmap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>obj</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new bitmap object from existing data.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>A pgmemdata structure, as returned by a pgFrom* function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new bitmap object created in the PicoGUI server</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, <a class="el" href="api_8c.html#a27">pgDelete</a>, <a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a>, <a class="el" href="api_8c.html#a39">pgCreateBitmap</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="api.c::pgNewCursor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewCursor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a cursor that can be used for input filters.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the cursor</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a33">pgInFilterSend</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a36" doxytag="api.c::pgNewFont"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewFont </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>style</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new font object.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>name</em>&nbsp;</td><td>The name of the font to search for, or NULL </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td>The size (height in pixels) of the font to search for, or zero </td></tr>
    <tr><td valign=top><em>style</em>&nbsp;</td><td>Zero or more PG_FSTYLE_* flags or'ed together</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new font object created in the PicoGUI server</dd></dl>
Based on the supplied parameters, finds the closest installed font and creates an object describing it. For example: <div class="fragment"><pre>
fDefault = <a class="code" href="api_8c.html#a36">pgNewFont</a>(NULL,0,PG_FSTYLE_DEFAULT);                  <span class="comment">// Find the font marked as default</span>
fBold    = <a class="code" href="api_8c.html#a36">pgNewFont</a>(NULL,0,PG_FSTYLE_DEFAULT | PG_FSTYLE_BOLD); <span class="comment">// Bold version of the default font</span>
fBig     = <a class="code" href="api_8c.html#a36">pgNewFont</a>(NULL,40,PG_FSTYLE_ITALIC);                  <span class="comment">// A large italic font</span>
fFlush   = <a class="code" href="api_8c.html#a36">pgNewFont</a>(<span class="stringliteral">"Helvetica"</span>,0,PG_FSTYLE_FLUSH);             <span class="comment">// Helvetica at the default size, with no space at the edges</span>
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a40">pgNewString</a>, <a class="el" href="api_8c.html#a27">pgDelete</a>, <a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a>, <a class="el" href="api_8c.html#a51">pgGetFontStyle</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="api.c::pgNewInFilter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewInFilter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>insert_after</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>accept_trigs</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>absorb_trigs</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new client-side input filter.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>insert_after</em>&nbsp;</td><td>This is the handle of the input filter to insert the new one after, or 0 to make this the first </td></tr>
    <tr><td valign=top><em>accept_trigs</em>&nbsp;</td><td>Mask of PG_TRIGGER_* constants for triggers to send in a PG_NWE_INFILTER event </td></tr>
    <tr><td valign=top><em>absorb_trigs</em>&nbsp;</td><td>Specifies a mask of triggers to prevent from automatically passing on to the next filter</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new input filter</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a24">pgNewCursor</a>, <a class="el" href="api_8c.html#a33">pgInFilterSend</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a37" doxytag="api.c::pgNewPopup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewPopup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a popup box, centered on the screen.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the popup box root widget</dd></dl>
<code>width</code> and/or <code>height</code> can be PGDEFAULT (zero) to determine the size automatically. This is preferred because the app should assume as little as possible about physical screen coordinates.<p>
NOTE: This function is now just a shortcut for creating a popup widget and setting its PG_WP_ABSOLUTEX, PG_WP_ABSOLUTEY, PG_WP_WIDTH, and PG_WP_HEIGHT properties<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a35">pgNewPopupAt</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a35" doxytag="api.c::pgNewPopupAt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewPopupAt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>width</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a popup box at the specified position.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the popup box root widget</dd></dl>
<code>width</code> and/or <code>height</code> can be PGDEFAULT (zero) to determine the size automatically. This is preferred because the app should assume as little as possible about physical screen coordinates.<p>
<code>x</code> and/or <code>y</code> can be a PG_POPUP_* constant:<ul>
<li>PG_POPUP_CENTER: Centered on the screen, same behavior as pgNewPopup</li><li>PG_POPUP_ATCURSOR: At the pointing device's cursor. If the cursor is over a button or menuitem, the popup snaps to its edge automatically</li></ul>
<p>
NOTE: This function is now just a shortcut for creating a popup widget and setting its PG_WP_ABSOLUTEX, PG_WP_ABSOLUTEY, PG_WP_WIDTH, and PG_WP_HEIGHT properties<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a37">pgNewPopup</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a40" doxytag="api.c::pgNewString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewString </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>str</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new string object.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>str</em>&nbsp;</td><td>The string make an object with </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handle to the new string object created in the PicoGUI server</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, <a class="el" href="api_8c.html#a27">pgDelete</a>, <a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="api.c::pgNewWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgNewWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rship</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>parent</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new widget, derived from a parent widget.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>type</em>&nbsp;</td><td>A PG_WIDGET_* constant for the widget type </td></tr>
    <tr><td valign=top><em>rship</em>&nbsp;</td><td>A PG_DERIVE_* constant indicating the new widget's relationship to it's parent. It can be PGDEFAULT. </td></tr>
    <tr><td valign=top><em>parent</em>&nbsp;</td><td>The parent widget's handle, or PGDEFAULT.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A handlet to the new widget</dd></dl>
<code>rship</code> indicates where in the widget stacking order, relative to the parent, the new widget will be:<ul>
<li>PG_DERIVE_INSIDE: For container widgets, put the new widget inside the parent but before other widgets that may already be inside it.</li><li>PG_DERIVE_BEFORE: Before the parent widget in the stacking order</li><li>PG_DERIVE_AFTER: After the parent widget in the stacking order</li></ul>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a29">pgSetWidget</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="api.c::pgRegisterApp"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgRegisterApp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>name</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a new application.
<p>
&lt; Send PG_NWE_PNTR_RAW from the specified widget     </td>
  </tr>
</table>
<a name="a17" doxytag="api.c::pgRegisterOwner"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgRegisterOwner </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>resource</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register exclusive access to a resouce.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>resource</em>&nbsp;</td><td>A PG_OWN_* constant indicating the resource you request</td></tr>
  </table>
</dl>
If the resource is already in use or cannot be obtained, a client error is triggered<p>
<dl compact><dt><b>See also:</b></dt><dd>PG_OWN_KEYBOARD, PG_OWN_POINTER, PG_OWN_SYSEVENTS </dd></dl>
    </td>
  </tr>
</table>
<a name="a58" doxytag="api.c::pgRender"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgRender </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>bitmap</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>groptype</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Render a gropnode to a bitmap.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>bitmap</em>&nbsp;</td><td>A bitmap handle to render to. Alternatively, if the app has registered exclusive display access this can be zero to draw directly to the display. </td></tr>
    <tr><td valign=top><em>groptype</em>&nbsp;</td><td>A PG_GROP_* constant indicating the type of gropnode</td></tr>
  </table>
</dl>
Gropnode parameters follow the gropnode type.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a57">pgWriteCmd</a>, <a class="el" href="pgfx__bitmap_8c.html#a23">pgNewBitmapContext</a>, <a class="el" href="api_8c.html#a17">pgRegisterOwner</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a54" doxytag="api.c::pgReplaceText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgReplaceText </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>str</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change a widget's text.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>widget</em>&nbsp;</td><td>A pointer to a widget with the PG_WP_TEXT property </td></tr>
    <tr><td valign=top><em>str</em>&nbsp;</td><td>The string to set PG_WP_TEXT to</td></tr>
  </table>
</dl>
This function performs the following steps:<ul>
<li>Calls pgGetWidget to find the old text handle</li><li>Uses pgNewString to get a handle to the new text</li><li>Uses pgSetWidget to send the new handle to the widget</li><li>If the old handle was non-NULL, deletes it with pgDelete</li></ul>
<p>
It is the preferred way of setting or changing the text of a button, label, or other widget that takes a PG_WP_TEXT property.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a45">pgGetWidget</a>, <a class="el" href="api_8c.html#a40">pgNewString</a>, <a class="el" href="api_8c.html#a29">pgSetWidget</a>, <a class="el" href="api_8c.html#a27">pgDelete</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a55" doxytag="api.c::pgReplaceTextFmt"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgReplaceTextFmt </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>fmt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change a widget's text, with formatting.
<p>
This function is equivalent to pgReplaceText, with support for printf-style formatting<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a54">pgReplaceText</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a6" doxytag="api.c::pgSetContext"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSetContext </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>id</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the context ID used when creating new handles.
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a7">pgDeleteHandleContext</a>, <a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a>, <a class="el" href="api_8c.html#a4">pgGetContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a22" doxytag="api.c::pgSetInactivity"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSetInactivity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>time</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the inactivity timer.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Inactivity</em>&nbsp;</td><td>timer value in milliseconds</td></tr>
  </table>
</dl>
This sets the inactivity timer. Set it to zero periodically if you want to prevent screensavers or sleep modes from activating even if there is no user input.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a23">pgGetInactivity</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a16" doxytag="api.c::pgSetPayload"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSetPayload </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>object</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>payload</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set an object's payload.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A handle to any PicoGUI object </td></tr>
    <tr><td valign=top><em>payload</em>&nbsp;</td><td>A 32-bit piece of application-defined data</td></tr>
  </table>
</dl>
The "payload" is a client-defined chunk of data attatched to any object that has a handle. Some good uses for this are assigning numerical values to buttons, or even creating a linked list of objects by storing a handle in the payload. It is usually possible for the client to store pointers in the payload, but this is not recommended, for two reasons:<ul>
<li>If the pgserver is buggy or compromised, the client is vulnerable to crashes or data corruption</li><li>If the client-side architecture uses pointers of more than 32 bits, it will not work</li></ul>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a20">pgGetPayload</a>, <a class="el" href="netcore_8c.html#a38">pgGetEvent</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="api.c::pgSetVideoMode"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSetVideoMode </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>xres</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>yres</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>bpp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flagmode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change video mode at runtime.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>xres</em>&nbsp;</td><td>New horizontal resolution </td></tr>
    <tr><td valign=top><em>yres</em>&nbsp;</td><td>New vertical resolution </td></tr>
    <tr><td valign=top><em>bpp</em>&nbsp;</td><td>Color depth in bits per pixel </td></tr>
    <tr><td valign=top><em>flagmode</em>&nbsp;</td><td>PG_FM_* constant specifying how to combine <code>flags</code> with the current video flags</td></tr>
  </table>
</dl>
<code>xres,</code> <code>yres,</code> and <code>bpp</code> can be zero to keep the current values.<p>
<code>flagmode</code> can have the following values:<ul>
<li>PG_FM_SET: Set all video flags to the specified value</li><li>PG_FM_ON: Turns on specified flags, leaves others untouched</li><li>PG_FM_OFF: Turns off specified flags</li><li>PG_FM_TOGGLE: Toggles specified flags</li></ul>
<p>
<code>flags</code> specifies extra optional features that may be present in the video driver. Unsupported flags are ignored. It can be zero or more of the following values or'ed together:<ul>
<li>PG_VID_FULLSCREEN: Uses a fullscreen mode if available</li><li>PG_VID_DOUBLEBUFFER: Uses double buffering if available</li><li>PG_VID_ROTATE90, PG_VID_ROTATE180, PG_VID_ROTATE270: Rotate the screen by the indicated number of degrees anticlockwise. All rotation flags are mutually exclusive.</li></ul>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a52">pgGetVideoMode</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a29" doxytag="api.c::pgSetWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSetWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set widget properties.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>widget</em>&nbsp;</td><td>Widget handle, may be PGDEFAULT</td></tr>
  </table>
</dl>
After <code>widget,</code> pgSetWidget accepts a list of property-value pairs terminated by a zero. For example:<p>
<div class="fragment"><pre>
<a class="code" href="api_8c.html#a29">pgSetWidget</a>(wLabel,
            PG_WP_TEXT,<a class="code" href="api_8c.html#a40">pgNewString</a>(<span class="stringliteral">"Hello"</span>),
            PG_WP_FONT,<a class="code" href="api_8c.html#a36">pgNewFont</a>(<span class="stringliteral">"Helvetica"</span>,12,0),
            0);
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a34">pgNewWidget</a>, <a class="el" href="api_8c.html#a45">pgGetWidget</a>, <a class="el" href="api_8c.html#a40">pgNewString</a>, <a class="el" href="api_8c.html#a36">pgNewFont</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a48" doxytag="api.c::pgSizeBitmap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSizeBitmap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>h</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>bitmap</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the size of a bitmap object.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>w</em>&nbsp;</td><td>The address to return the width in </td></tr>
    <tr><td valign=top><em>h</em>&nbsp;</td><td>The address to return the height in </td></tr>
    <tr><td valign=top><em>bitmap</em>&nbsp;</td><td>Handle to a valid PicoGUI bitmap object</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a39">pgCreateBitmap</a>, <a class="el" href="api_8c.html#a38">pgNewBitmap</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a47" doxytag="api.c::pgSizeText"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSizeText </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>h</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>font</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>text</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Measure a string of text.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>w</em>&nbsp;</td><td>The address to return the width in </td></tr>
    <tr><td valign=top><em>h</em>&nbsp;</td><td>The address to return the height in </td></tr>
    <tr><td valign=top><em>font</em>&nbsp;</td><td>A font to render the text in </td></tr>
    <tr><td valign=top><em>text</em>&nbsp;</td><td>A handle to the text to measure</td></tr>
  </table>
</dl>
In <code>*w</code> and <code>*h,</code> returns the size in pixels of the given text in the given font. Font may be PGDEFAULT to use the default font.<p>
Note that if you use pgNewText to create a string object just for this function call, you should delete it afterwards to prevent a memory leak: <div class="fragment"><pre>
pghandle sText;
<span class="keywordtype">int</span> w,h;

sText = <a class="code" href="api_8c.html#a40">pgNewString</a>(<span class="stringliteral">"Hello, World!"</span>);
<a class="code" href="api_8c.html#a47">pgSizeText</a>(&amp;w,&amp;h,PGDEFAULT,sText);
<a class="code" href="api_8c.html#a27">pgDelete</a>(sText);
 
</pre></div><p>
Alternatively, defining a context with pgEnterContext and pgLeaveContext will clean up the string object automatically: <div class="fragment"><pre>
<a class="code" href="api_8c.html#a3">pgEnterContext</a>();
<a class="code" href="api_8c.html#a47">pgSizeText</a>(&amp;w,&amp;h,PGDEFAULT,<a class="code" href="api_8c.html#a40">pgNewString</a>(<span class="stringliteral">"Hello, World!"</span>);
<a class="code" href="api_8c.html#a5">pgLeaveContext</a>();
 
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a3">pgEnterContext</a>, <a class="el" href="api_8c.html#a5">pgLeaveContext</a>, <a class="el" href="api_8c.html#a40">pgNewString</a>, <a class="el" href="api_8c.html#a36">pgNewFont</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="api.c::pgSubUpdate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgSubUpdate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>widget</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Update a subsection of the screen.
<p>
The given widget and all other widgets contained within it are redrawn if necessary. The request buffer is flushed and the section is redrawn independantly and immediately.<p>
This function is recommended for animation. Areas of the screen other than the specified widget and its children are never updated, and SubUpdates can occur in toolbars even while a popup dialog is onscreen.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a2">pgUpdate</a>, <a class="el" href="netcore_8c.html#a34">pgFlushRequests</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a66" doxytag="api.c::pgSyncAppMessage"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* pgSyncAppMessage </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a message to a widget owned by any application, and wait for an answer.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>dest</em>&nbsp;</td><td>Handle of the destination widget </td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>A pgmemdata structure containing the data, as returned by a pgFrom* function</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a pointer to the answer message. This will have to be freed by the calling application.</dd></dl>
The <code>data</code> parameter is sent as the <code>data</code> in a PG_WE_APPMSG event on behalf of the <code>dest</code> widget.<p>
This call acts very similarly to <code>pgAppMessage,</code> except that the calling client is blocked until the remote widget has sent an answer message. The answer is application specific.<p>
NOTE: The data is assumed to be a structure whose very first field is of type <code>pghandle.</code> This field will be used by pgSyncAppMessage to store the widget handle to which the receiver will send the answer.     </td>
  </tr>
</table>
<a name="a11" doxytag="api.c::pgThemeLookup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u32 pgThemeLookup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>object</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>property</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve a theme property.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A PGTH_O_* theme object constant </td></tr>
    <tr><td valign=top><em>property</em>&nbsp;</td><td>A PGTH_P_* theme property constant</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The theme property's value</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a9">pgLoadTheme</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a46" doxytag="api.c::pgTraverseWidget"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> pghandle pgTraverseWidget </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>direction</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finds a widget in relation to another widget.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>widget</em>&nbsp;</td><td>The widget being referenced </td></tr>
    <tr><td valign=top><em>direction</em>&nbsp;</td><td>A direction to traverse specified with a PG_TRAVERSE_* constant </td></tr>
    <tr><td valign=top><em>count</em>&nbsp;</td><td>The number of steps to take in that direction</td></tr>
  </table>
</dl>
There are four possible values for <code>direction</code> at this time:<ul>
<li>PG_TRAVERSE_CHILDREN returns the count'th child of the specified widget</li><li>PG_TRAVERSE_FORWARD returns the widget added count'th widgets after this widget</li><li>PG_TRAVERSE_BACKWARD the opposite of forward</li><li>PG_TRAVERSE_CONTAINER travels to the widget's container, for <code>count</code> iterations</li><li>PG_TRAVERSE_APP travels to the root widget that contains the specified widget, then forward in the application list for <code>count</code> iterations. If the <code>widget</code> is 0, it returns the first app root widget. Note that the app list is continuously sorted by "Z-order". </li></ul>
    </td>
  </tr>
</table>
<a name="a18" doxytag="api.c::pgUnregisterOwner"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgUnregisterOwner </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>resource</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unregister exclusive access to a resouce.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>resource</em>&nbsp;</td><td>A PG_OWN_* constant indicating the resource you release</td></tr>
  </table>
</dl>
An error will be triggered if the client does not already own the specified resource.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a17">pgRegisterOwner</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="api.c::pgUpdate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgUpdate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Update the screen.
<p>
Redraw portions of the screen if necessary. This forces all unsent packets to be flushed to the server, and instructs the server to draw changed areas of the screen.<p>
If your application is pgEventLoop (or pgGetEvent) based, this is handled automatically. The server always updates the screen before waiting for user interaction.<p>
For doing animation, consider using pgSubUpdate instead.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="netcore_8c.html#a34">pgFlushRequests</a>, <a class="el" href="api_8c.html#a25">pgSubUpdate</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a57" doxytag="api.c::pgWriteCmd"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgWriteCmd </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>command</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>s16&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>numparams</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write a command to a widget.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>widget</em>&nbsp;</td><td>The handle of the widget to receive the command </td></tr>
    <tr><td valign=top><em>command</em>&nbsp;</td><td>A widget-defined command number </td></tr>
    <tr><td valign=top><em>numparams</em>&nbsp;</td><td>The number of parameters following this one</td></tr>
  </table>
</dl>
This function creates a pgcommand structure from it's arguments and uses pgWriteData to send it to the specified widget. Currently this is used as the low-level interface to the canvas widget.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a56">pgWriteData</a>, PG_WIDGET_CANVAS, <a class="el" href="pgfx__canvas_8c.html#a23">pgNewCanvasContext</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a56" doxytag="api.c::pgWriteData"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void pgWriteData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">pghandle&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>widget</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structpgmemdata.html">pgmemdata</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write data to a widget.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>widget</em>&nbsp;</td><td>The handle of the widget to receive data </td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>A pgmemdata structure containing the data, as returned by a pgFrom* function</td></tr>
  </table>
</dl>
Write a chunk of widget-defined data to a widget. For example, this can be used to send text to a terminal widget or commands to a canvas widget. (For canvas drawing pgWriteCmd or PGFX should usually be used instead)<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="api_8c.html#a12">pgFromMemory</a>, <a class="el" href="api_8c.html#a14">pgFromFile</a>, <a class="el" href="api_8c.html#a15">pgFromStream</a>, <a class="el" href="api_8c.html#a13">pgFromTempMemory</a>, PG_WIDGET_TERMINAL, PG_WIDGET_CANVAS, <a class="el" href="api_8c.html#a57">pgWriteCmd</a>, <a class="el" href="pgfx__canvas_8c.html#a23">pgNewCanvasContext</a> </dd></dl>
    </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Fri May 23 03:39:45 2003 for PicoGUI by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
